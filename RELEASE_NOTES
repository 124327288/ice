======================================================================
Release notes for Ice 3.3.1
======================================================================

Introduction
------------

This documents outlines changes and improvements in this release that
may affect the operation of your applications or have impact on your
source code. See the section titled "Upgrading your application"
for more information about migrating to a new Ice release.

Note that because the Python, Ruby, and PHP language mappings use the
C++ Ice run time, they automatically benefit from fixes to the C++ Ice
core even if these language mappings are not explicitly mentioned
below.


Table of Contents
-----------------

  1. New Features
  2. Fixes and improvements
  3. Upgrading your application
     - Upgrading from Ice 3.2 or earlier releases
     - Upgrading from Ice 3.3.0
     - Migrating IceStorm databases
     - Migrating IceGrid databases
     - Migrating Freeze databases
     - Removed APIs
     - Deprecated APIs
  4. Platform-specific notes
     - IBM JDK
     - Java and IPv6
     - Mono
     - Red Hat Enterprise Linux 5.1
  5. Known Problems


======================================================================
1. New Features
======================================================================

This section discusses the significant enhancements offered in this
release.

Features added with 3.3.1
=========================

Protobuf
--------

This release integrates the ZeroC Labs release for Google protocol
buffers. This feature allow you to serialize and deserialize data to
and from protocol buffers and transmit these via Ice operation
invocations with Ice for C++, Java, and Python. A new protobuf
demo illustrates how to use this feature.


Java and .NET serialization
---------------------------

This release adds support for Java and .NET serializable classes. You
can now enable the serialization, transmission, and deserialization
of Java and .NET classes with a simple metadata directive. A new
serialize demo illustrates how to use this feature.


Locator cache updates
---------------------

A new property, Ice.BackgroundLocatorCacheUpdates, controls how
the locator updates its cached endpoints. By setting this property
to 1, endpoints are updated in the background instead of delaying
the first invocation that is made after an endpoint times out until
the current endpoint information has been retrieved.


Connection reaping
------------------

If you enable ACM, the Ice run time selects a reaping interval
that is based on the client and server ACM settings. You can
override this default interval by setting the property
Ice.MonitorConnections.


Glacier2 session management
---------------------------

Glacier2 now automatically destroys a client session if forwarding
from the server to the client fails with an unrecoverable error.
This prevents stale session from accumulating, provided that
timeouts are configured on the Glacier2 client endpoints.


Applet demo
-----------

Ice for Java now includes an applet demo that illustrates how
to use asynchronous invocations in a GUI applications and how to
configure IceSSL for the applet.


Exception slicing trace
-----------------------

Setting Ice.Trace.Slicing property now traces user exception unmarshaling
with Ice for Python and Ice for Ruby.


NRVO with Ice for C++
---------------------

slice2cpp new generates code to better take advantage of NRVO (Named
Return Value Optimization), which reduces the number of data copies
during marshaling. This can improve marshaling performances by 20%
for sequences containing many values. To take advantage of this
optimization, you must recompile your Slice files and application
code.


64-bit integers with Ice for Python
-----------------------------------

It is now possible to pass a sequence of 64-bit integer values
using an object that supports the buffer protocol.


Multiple Slice files with Ice for PHP
-------------------------------------

You can now specify multiple Slice files in the profile configuration
if the files include a common file without causing an error.


Features added with 3.3.0
=========================

AMI
---

AMI requests are now guaranteed non-blocking. New proxy methods,
ice_flushBachRequests and ice_flushBatchRequests_async, allow
flushing of requests batched for a connection. The latter method
is guaranteed to not block. AMI requests can now be sent oneway.


Threads
-------

The Ice thread pool now suppots serialization of requests received over
a connection.


Exceptions
----------

Exceptions thrown from collocation-optimizaed invocations are now fully
transparent, so a collocated invocation raises the same exception
as a remote invocation. (Previously, collocated invocation raised
the original exception where the corresponding remote invocation raised
an unknown exception.)

Servant locators now can throw user exception from the locate and finished
operations.


Transport
---------

The run time now tries to connect to multi-homed hosts on all IP
addresses returned by the DNS.

Ice.TCP.Backlog allows control of the incoming connection backlog.

Ice now supports IPv6.

Ice now supports UDP multicast.

A new adapter operation, refreshPublishedEndpoints, permits you to
update an adapter's published endpoints after a change to the available
interfaces or an update to the PublishedEndpoints property.

Ice now listens on INADDR_ANY for endpoints that do not specify a
host, instead of listening only the interfaces that were present
when the adapter was created.


IceBox
------

IceBox can now recursively start and stop other IceBox services.

IceBox properties can now be defined on the command line.

Setting IceBox.ServiceManager.Endpoints is now optional.


IceStorm
--------

IceStorm now supports master/slave replication with automatic failover.

IceStorm now has a transient mode that allows it to run without a database.

IceStorm subscriptions are now persistent (except in transient mode).

A new QoS parameter, retryCount, allows you to control after how many
soft failures a subscription is removed.

A new replication2 demo illustrates how to manually configure replication.

IceStorm now guarantees ordering by default even for oneway proxies.


Freeze
------

The existing evictor is now named BackgroundSaveEvictor. A new
evictor, TransactionalEvictor, makes updates in a transaction.


IceGrid
-------

A new secure demo illustrates how to secure an IceGrid deployment.


Miscellaneous features
----------------------

Ice for Java now supports the ICE_CONFIG environment variable.

Ice.Application now supports signal handling with Mono.

Improves marshaling performance improvements with Ice for .NET.

Ice for .NET now supports C# 2.0 generics for sequences and
dictionaries.

Ice for Python now includes a converter demo that illustrates
how to use the C++ string converter plug-in.

Ice for Python now supports blobjects.


======================================================================
2. Fixes and improvements
======================================================================

Below is an abbreviated list of changes included in this release that
were not already discussed in "New Features". For a complete list of
changes, please refer to the CHANGES file included in your Ice
distribution.


Fixes for release 3.3.1
-----------------------

* Fixed a number of bugs in the Slice translators that caused invalid
  code to be generated.

* All error output from the Slice translators now goes to stderr
  instead of stdout.

* Fixed IceGrid registry crash triggered by resolving the endpoints
  of a replica group while servers were activating concurrently.

* Fixed IceGrid bug that cause inadvertent deactivation of servers
  during an application update.

* Fixed IceGrid bug that caused incorrect config files to be generated
  for servers with an ice-version prior to 3.3.0.

* Fixed icegridamin crash when listing services.

* Fixed a Freeze transactional evictor bug that could cause inadvertent
  rollback of a transaction with AMD.

* Ice for Ruby now generates an eql? method for Slice structures. (That
  method was missing previously, preventing the use of structures as
  dictionary keys.)

* In Python, the code generated for the constructors of Slice classes,
  structures and exceptions contained a subtle bug that only affects
  data members of type 'struct'. Consider the following Slice
  definitions:

  struct Point {
      int x;
      int y;
  };
  struct Event {
      Point location;
      ...
  };

  The Event constructor supplied a default instance of the Point
  member if the caller did not supply one:

  class Event(...):
      def __init__(self, location=Point()):
          self.location = location

  The intent is to ensure that a structure data member ('location' in
  this example) is fully constructed. However, since Python evaluates
  default arguments only once, this had the unintentional side effect
  of causing all Event instances to share the same instance of Point
  unless the caller explicitly supplied a value for the location
  parameter.

  The generated code now ensures that each instance of Event assigns a
  new instance of Point if the caller does not supply a value.
  

Fixes for release 3.3.0
-----------------------

* An IceBox service can now recursively start and stop other IceBox
  services from within its start and stop methods. The level of
  recursion is limited to the threads in the administrative object
  adapter's thread pool.

* IceBox services that share a communicator now use a dedicated
  communicator instance that is not used by the IceBox server. This
  dedicated communicator only inherits properties from the server's
  communicator if IceBox.InheritProperties is set to a non-zero value.

* It is no longer necessary to define a value for the property
  IceBox.ServiceManager.Endpoints. If this property is not defined,
  the ServiceManager interface is not available.

* Configuration properties for IceBox services can now be defined on
  the command line.

* A new object adapter property, <adapter>.ProxyOptions, lets you
  customize the proxies that the adapter creates.

* Accepting incoming connections can no longer block a thread from a
  server thread pool. This includes activities such as connection
  validation and SSL handshaking.

* The new property Ice.TCP.Backlog allows you to specify the size of
  incoming connection backlog for TCP/IP sockets. This setting is
  also used for SSL. In C++ the default value is SOMAXCONN or 511 if
  that macro is not defined. In Java and .NET the default value is
  511.

* Changed servant locators so both locate() and finished() can throw
  user exceptions.

* It is now legal to change the compression setting of a fixed proxy.

* An IceGrid node is more conservative when removing the directory of
  a server. The node only removes the directory when the server is
  explicitly removed from a deployed application or if the directory
  contains only files and directories that were created by the node.

* IceGrid's round-robin load balancing policy better handles servers
  that are unreachable.

* When resolving the endpoints of a replica group, the IceGrid locator
  no longer waits for an object adapter to complete its activation if
  another adapter is already active.

* Added an object adapter to the IceGrid registry. The adapter is
  named `IceGrid.Registry.AdminSessionManager' and is responsible for
  Glacier2 administrative sessions.

* Glacier2 filters are now disabled by default for IceGrid client
  and administrative sessions created with the IceGrid session
  managers. If you rely on these filters being enabled, you must now
  explicitly set the property IceGrid.Registry.SessionFilters or
  IceGrid.Registry.AdminSessionFilters.

* The IceGrid node now unblocks the SIGHUP, SIGINT and SIGTERM signals
  from forked servers.

* Several improvements have been made to the output of slice2html.

* The inheritance structure of C++ servant classes has changed such
  that it is now possible for a servant to derive from
  IceUtil::Thread.

* If a proxy contains a host that is multihomed, the client will now
  try all of the IP addresses reported by DNS. Previously, only the
  first address in the list was used and others were ignored.

* The way that the Ice run time determines whether a proxy invocation
  is eligible for collocation optimization has changed somewhat. The
  Ice run time no longer performs a DNS lookup; instead, invocations
  on a direct proxy will use the optimization only if the host and
  port of one of its endpoints match the host and port of an endpoint
  or published endpoint of an object adapter from the same
  communicator.

* Exceptions thrown from collocation-optimized invocations are now
  fully transparent. If an operation throws an exception that is
  not in the operation's exception specification, or throws a
  non-Ice exception, the client receives UnknownUserException
  or UnknownException, exactly as if the servant for a remote
  invocation had thrown the same exception. (In earlier versions,
  the client received the original exception, rather than an
  unknown exception.)

  For Ice run-time exceptions, all run-time exceptions are passed
  to the client as UnknownLocalException, except for

  - ObjectNotExistException
  - FacetNotExistException
  - OperationNotExistException
  - OperationNotExistException
  - UnknownException
  - UnknownLocalException
  - UnknownUserException
  - CollocationOptimizationException

* Most proxy factory methods now return a proxy of the same type as
  the original and no longer require the use of a checked or unchecked
  cast. For example, in C++ you can write

  HelloPrx hello = ...;
  hello = hello->ice_oneway();

  Previously you would have needed a cast, such as

  hello = HelloPrx::uncheckedCast(hello->ice_oneway());

  In Java and .NET, you must use a type cast:

  hello = (HelloPrx)hello.ice_oneway();

* The IceSSL plugins for Java and .NET now support a password callback
  interface. You can also specify the class name of a certificate
  verifier or password callback via configuration properties.

* It is now possible to use Ice's built-in sequence types in Slice
  data structures that are compiled with streaming support. Previously
  this would not work because the Ice sequences were not compiled with
  streaming support.

* Changed Ice.Exception in .NET to derive from System.Exception
  instead of System.ApplicationException in accordance with
  Microsoft's recommendations for writing custom exceptions.

* The Ice.Application class now supports signal handling on Mono.

* The .NET build system supports the new macro MANAGED, which can be
  enabled if you want to build a version of the Ice run time that uses
  only managed code.

* Marshaling performance in .NET has been improved.

* The rules for legal property names and values have been relaxed.
  Refer to the "Properties" chapter in the Ice manual for a complete
  description of the syntax. The limit on the line length of a
  property in a configuration file has also been removed.

* The new property Ice.Warn.UnusedProperties causes the communicator
  to display a warning during its destruction that lists all
  properties that were set but whose values were never read.

* It is now possible to use UNC paths on Windows in the configuration
  of Ice services.

* A string converter plugin has been added to Ice for C++, which is
  particularly useful for the scripting language extensions.

* Ice for Python now accepts Unicode objects as arguments to remote
  operations.


======================================================================
3. Upgrading your application
======================================================================

Ice 3.3 does not maintain backward binary compatibility with
applications built using Ice 3.2 and earlier, but every effort was made to
preserve source compatibility. Note however that Ice always maintains
protocol ("on the wire") compatibility with prior releases.

Certain APIs that were deprecated in earlier minor Ice releases
have been removed in this release. If your application relies on one
of these APIs, it may no longer compile or execute correctly. A list
of the removed APIs is provided in the section titled "Removed APIs"
along with a description of their replacements. Furthermore, the
section "Deprecated APIs" discusses APIs that are deprecated as of
release 3.3.0; we encourage you to update your applications and
eliminate the use of these APIs as soon as possible.

If your application uses IceStorm, IceGrid, or Freeze, please refer to the
relevant sections below for migration instructions.

The requirements for upgrading depend on the language mapping used by
your application.

Upgrading from Ice 3.2 or earlier releases
------------------------------------------

- For statically-typed languages (C++, Java, .NET), you must recompile
  the application.

- For scripting languages that use static translation, you must
  recompile your Slice files.

Upgrading from Ice 3.3.0
------------------------

- For scripting languages that use static translation, you need
  not recompile your Slice files.

- You can upgrade applications compiled with release 3.3.0 to use release 3.3.1
  libraries without recompilation as follows:

  - C++, Python, Ruby, and PHP

    Python, Ruby, and PHP use the Ice for C++ run time, so upgrading Ice for
    C++ automatically upgrades Ice for Python, Ruby, and PHP.

    - Unix systems

      Install a new binary release of Ice 3.3.1 or compile Ice 3.3.1 and run
      a "make install". This changes the symbolic link for the installation
      directory to point at the new installation; therefore, applications compiled
      with Ice 3.3.0 automatically load the 3.3.1 libraries (assuming your
      LD_LIBRARY_PATH or DYLD_LIBRARY_PATH uses the symbolic link).

      Alternatively, you can set your LD_LIBRARY_PATH or DYLD_LIBRARY_PATH to
      specifically include the 3.3.1 lib directory instead of the 3.3.0 one.

    - Windows

      Set your PATH to include the bin directory for Ice 3.3.1 instead of 3.3.0.

  - Java

    Replace the Ice.jar file from release 3.3.0 with the Ice.jar file
    from release 3.3.1. This causes applications compiled with 3.3.0 to
    use the 3.3.1 run time. Alternatively, change your CLASSPATH to point
    at the Ice.jar for 3.3.1.

  - .NET and Mono

    Ice for .NET includes policy assemblies that supply the
    run time with the required compatibility information. Policy assemblies
    have names of the form policy.@mmver@.<package>.dll.  For example, the policy
    assembly for IceBox is policy.@mmver@.IceBox.dll.

    - .NET

      To upgrade an existing .NET application to a new patch release, the
      policy assemblies must be installed into the Global Assembly Cache (GAC).
  
      On Windows, open Windows Explorer and navigate to the directory 
      C:\WINDOWS\assembly. Next, drag and drop (or copy and paste) the
      assemblies into the right-hand pane to install them in the GAC.
  
      Or you can use gacutil from the command line to achieve the same result:

          gacutil -i <policy.dll>

    - Mono

      You can either install the policy assemblies in the GAC using gacutil as for .NET,
      or ensure that they are present in your MONO_PATH.


Migrating IceStorm databases
----------------------------

Ice 3.3 supports migrating IceStorm databases from Ice 3.1 and from
Ice 3.2. Migration from other Ice versions may work, but is not
officially supported. If you require assistance with this please
contact sales@zeroc.com.

To migrate, first stop your IceStorm servers.

Next, copy the IceStorm database environment to a second location:

$ cp -r db recovered.db

Run the Berkeley DB utility db_recover on the copied database
environment:

$ db_recover -h recovered.db

Note that it is essential that the correct version of db_recover is
used. For Ice 3.1, Berkeley DB 4.3.29 must be used. For Ice 3.2,
Berkeley DB 4.5 must be used.

Now change to the location where the Ice 3.3 IceStorm database
environments are stored:

$ cd <new-location>

Next, run the icestormmigrate utility. The first argument is the path
to the old database environment. The second argument is the path to
the new database environment.

In this example we'll create a new directory "db" in which to store
the migrated database environment:

$ mkdir db
$ icestormmigrate <path-to-recovered.db> db

The migration is now complete, and the contents of the old database
environment are now in the db directory.


Migrating IceGrid databases
---------------------------

Ice 3.3 supports migrating IceGrid databases from Ice 3.1 and from Ice
3.2. Migration from other Ice versions may work, but is not officially
supported. If you require assistance with this please contact
sales@zeroc.com.

To migrate, first stop the IceGrid registry you wish to upgrade.

Next, copy the IceGrid database environment to a second location:

$ cp -r db recovered.db

Run the Berkeley DB utility db_recover on the copied database
environment:

$ db_recover -h recovered.db

Note that it is essential that the correct version of db_recover is
used. For Ice 3.1, Berkeley DB 4.3.29 must be used. For Ice 3.2,
Berkeley DB 4.5 must be used.

Now change to the location where the Ice 3.3 IceGrid database
environments are stored:

$ cd <new-location>

Next, run the upgradeicegrid.py utility located in the `config'
directory of your Ice distribution (or in /usr/share/Ice-3.3.0 if using
an RPM installation). The first argument is the path to the old
database environment. The second argument is the path to the new
database environment.

In this example we'll create a new directory "db" in which to store
the migrated database environment:

$ mkdir db
$ upgradeicegrid.py <path-to-recovered.db> db

The migration is now complete, and the contents of the old database
environment are now in the db directory.

By default, the migration utility assumes that the servers deployed
with IceGrid also use Ice 3.3. If your servers still use an older Ice
version, you need to specify the --server-version command-line option
when running upgradeicegrid.py:

$ upgradeicegrid.py --server-version 3.2.1 <path-to-recovered.db> db

The migration utility will set the server descriptor `ice-version'
attribute to the specified version and the IceGrid registry will
generate configuration files compatible with the given version.

If upgrading the master IceGrid registry in a replicated environment
and the slaves are still running, you should first restart the master
registry in read-only mode using the --readonly option, for example:

$ icegridregistry --Ice.Config=config.master --readonly

Next, you can connect to the master registry with icegridadmin or the
IceGrid administrative GUI to ensure that the database is correct. If
everything looks fine, you can shutdown and restart the master
registry without the --readonly option.


Migrating Freeze Databases
--------------------------

There is no special Freeze procedure or Freeze tool to perform this 
upgrade. Freeze is still storing exactly the same data, in the same format.

However, we upgraded the version of Berkeley DB, and as a result when 
upgrading from Ice 3.2 to Ice 3.3, you have to upgrade your database 
from the "Berkeley DB 4.5" format to the new "Berkeley DB 4.6" format. 

This is fortunately straightforward, since the only relevant format change 
for Freeze was the log format change.

From the Berkeley DB Upgrade Process:

 http://www.oracle.com/technology/documentation/berkeley-db/db/ref/upgrade/process.html

If the application has a Berkeley DB transactional environment, and the
log files need upgrading but the databases do not, the application may be 
installed in the field using the following steps:

 1. Shut down the old version of the application.

 2. Still using the old version of Berkeley DB, run recovery on the database
    environment using the DB_ENV->open method or the db_recover utility.

 3. If you used the DB_ENV->open method to run recovery, make sure that the
    Berkeley DB environment is removed using the DB_ENV->remove method or 
    an appropriate system utility.

 4. Archive the database environment for catastrophic recovery.
    See Archival procedures for more information.

 5. Recompile and install the new version of the application.

 6. Force a checkpoint using the DB_ENV->txn_checkpoint method or
    the db_checkpoint utility. If you use the db_checkpoint utility, make sure
    to use the new version of the utility; that is, the version that came with
    the release of Berkeley DB to which you are upgrading.

 7. Restart the application. 

Is recommend to use the db_ utilities, and not write your own upgrade program!


Removed APIs
---------------

Release 3.3.0 removed a number of APIs. These APIs are no longer available.

* Thread per connection

  The primary purpose of this concurrency model was to serialize the
  requests received over a connection, either because the application
  needed to ensure that requests are dispatched in the order they are
  received, or because the application did not want to implement the
  synchronization that might be required when using the thread pool
  concurrency model.

  Another reason for using the thread-per-connection concurrency model
  is that it was required by the IceSSL plug-ins for Java and C#. This
  requirement has been eliminated.

  The ability to serialize requests is now provided by the thread pool
  and enabled via a new configuration property:

  <threadpool>.Serialize=1

  Please refer to the "Ice Run Time" chapter of the Ice manual for
  more details on this feature.

  Aside from the potential semantic changes involved in migrating your
  application to the thread pool concurrency model, other artifacts of
  thread-per-connection may be present in your application and must be
  removed:

  - The configuration properties Ice.ThreadPerConnection and
    <proxy>.ThreadPerConnection

  - The proxy methods ice_threadPerConnection and
    ice_isThreadPerConnection

* .NET metadata

  The metadata directive "cs:collection" is no longer valid. Use
  ["clr:collection"] instead.

* C++

  The following methods have been removed:

  - Application::main(int, char*[], const char*, const Ice::LoggerPtr&)

    Use Application::main(int, char*[], const InitializationData&)
    instead.

  - initializeWithLogger
  - initializeWithProperties
  - initializeWithPropertiesAndLogger

    Use initialize(int, char*[], const InitializationData&) instead.

  - stringToIdentity
  - identityToString

    Use the equivalent Communicator operations.

* Java

  The following methods have been removed:

  - Application.main(String, String[], String, Logger)

    Use Application.main(String, String[], InitializationData)
    instead.

  - initializeWithLogger
  - initializeWithProperties
  - initializeWithPropertiesAndLogger

    Use initialize(String[], InitializationData) instead.

* .NET

  The following methods have been removed:

  - Application.main(string, string[], string, Logger)

    Use Application.main(string, string[], InitializationData)
    instead.

  - initializeWithLogger
  - initializeWithProperties
  - initializeWithPropertiesAndLogger

    Use initialize(ref string[], InitializationData) instead.

* Python

  The following methods have been removed:

  - initializeWithLogger
  - initializeWithProperties
  - initializeWithPropertiesAndLogger

    Use initialize(args, initializationData) instead.

  - stringToIdentity
  - identityToString

    Use the equivalent Communicator operations.

* General

  The following methods have been removed:

  - ice_hash
  - ice_communicator
  - ice_collocationOptimization
  - ice_connection

    These proxy methods were replaced by ones of the form ice_get...,
    such as ice_getHash. ice_collocationOptimization is now
    ice_getCollocationOptimized.

  - ice_newIdentity
  - ice_newContext
  - ice_newFacet
  - ice_newAdapterId
  - ice_newEndpoints

    These proxy methods were replaced by ones that do not use "new" in
    their names. For example, ice_newIdentity was replaced by
    ice_identity.

* Ice.LoggerPlugin

  This property provided a way to install a custom logger
  implementation. It has been replaced by a more generalized facility
  for installing custom loggers.


Deprecated APIs
---------------

The Ice APIs and components listed below are deprecated.
We encourage you to update your applications and eliminate
the use of these APIs as soon as possible.

* Java2 language mapping

  Java5 is now the default language mapping. Applications that use the
  Java2 mapping can continue to use it by adding the appropriate
  metadata tag to your Slice files or by using the "--meta java:java2"
  option when running the Slice-to-Java compiler. Note that the
  compiler now emits a deprecation warning when it encounters the
  Java2 metadata tag.

  If you used the "java:java5" metadata tag when compiling your Slice
  definitions, you can now remove those tags. Any uses of custom type
  metadata ("java:type:...") should also be reviewed.

* Sequences as dictionary keys

  The use of sequences, and structures containing sequences, as the
  key type of a Slice dictionary is now deprecated.

* LocalObject

  The mappings for the LocalObject type have changed in Java, .NET and
  Python. The new mappings are shown below:

  Java    java.lang.Object
  .NET    System.Object
  Python  object

  The types Ice.LocalObject and Ice.LocalObjectImpl are deprecated.

* Ice.Trace.Location

  This property has been replaced by Ice.Trace.Locator.

* Ice.Default.CollocationOptimization

  This property, as well as the corresponding proxy property, have
  been replaced by Ice.Default.CollocationOptimized and
  <proxy>.CollocationOptimized, respectively.

* <Adapter>.RegisterProcess

  This property caused the Ice run time to register a proxy with the
  locator registry (e.g., IceGrid) that allowed the process to be shut
  down remotely. The new administrative facility (see "New Features")
  has replaced this functionality.

* Ice.ServerId

  As with <Adapter>.RegisterProcess, this property was used primarily
  for IceGrid integration and has been replaced by a similar mechanism
  in the administrative facility (see "New Features").

* Glacier2.Admin
  IcePatch2.Admin

  These are the names of administrative object adapters in Glacier2
  and IcePatch2, respectively. The functionality offered by these
  object adapters has been replaced by that of the administrative
  facility (see "New Features"), therefore these adapters (and their
  associated configuration properties) are deprecated.


======================================================================
4. Platform-specific notes
======================================================================


IBM JDK
--------

The IBM JDK ships with limited jurisdiction policy files for the
cryptographic libraries. This creates an issue for Ice's certificate
authority script (iceca) when running with the command-line options
"iceca java --import". The import fails with an error similar to:

  "java.lang.SecurityException: Unsupported keysize or algorithm
  parameters"

To solve this problem you must install the unlimited jurisdiction
policy files. For more information, including a link to download
the policy files, see:

  http://www.ibm.com/developerworks/java/jdk/security/50/

Once you have downloaded the policy files, you must unpack them into
the jre/lib/security directory.


Java and IPv6
-------------

IPv6 is not currently supported in Java on Windows due to a bug in the
JVM. Refer to the bug database for more information:

  http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6230761


Mono
----

Mono requires that a system's host name be correctly configured and
that it resolves to an IP address. Otherwise, Mono is unable to
determine the local IP addresses, which causes the creation of object
adapters that listen on INADDR_ANY/0.0.0.0 to fail with an
Ice::DNSException.


Red Hat Enterprise Linux 5.1
----------------------------

On Red Hat Enterprise Linux 5.1 systems, Ice connection establishment
to an inactive port of an IPv6 interface might hang instead of
immediately reporting "connection refused" (ECONNREFUSED). The hang
can last for several minutes and is similar to hangs you would get if
you try to connect to an unreachable address. This is a RHEL 5.1
kernel issue which has been fixed in the RHEL 5.2 kernel.

Refer to https://bugzilla.redhat.com/show_bug.cgi?id=248052 for more
information.

======================================================================
5. Known Problems
======================================================================

Slice-to-HTML
-------------

slice2html generates incorrect code for some legal constructs. The
problem is caused by bug in the mcpp preprocessor. For example:

module M
{
    class SomeClass; // Forward declaration. mcpp loses this.

    struct SomeStruct
    {
        SomeClass* proxy;
    };
};

The mcpp bug causes the forward declaration to be lost, resulting in
an undefined symbol error for the proxy member. To work around this
issue, you can move the trailing comment onto a separate line:

module M
{
    // Forward declaration. This works.
    class SomeClass;

    struct SomeStruct
    {
        SomeClass* proxy;
    };
};

Or you can use a C-style comment:

module M
{
    class SomeClass; /* Forward declaration. This works. */

    struct SomeStruct
    {
        SomeClass* proxy;
    };
};


UNC Paths and Slice conmpilers
------------------------------

The slice compilers currently do not allow specifying UNC paths in the
include directive. For example, the following will not work:

  slice2cpp -I\\MACHINE\SliceFiles Test.ice

It will report errors indicating it cannot find any of the files from
\\MACHINE\SliceFiles that were included in Test.ice. This is due to a
bug in the mcpp preprocessor.
