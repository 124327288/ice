Please see the file INSTALL.txt for installation instructions.


Asynchronous Message Invocation (AMI)
-------------------------------------

AMI is implemented differently in Ice for Silverlight than it is in
Ice for C#. Specifically, the means by which you define the callbacks
that are called once the AMI method either succeeds or fails is 
different.

In Ice for C# it is necessary for the application to extend an AMI
callback class generated by the Slice-To-C# translator and implement
the abstract ice_response() and ice_exception() methods in the 
extended class. A instance of this class is then passed to the async
call on the proxy.

For example consider the following slice:

    module Foo
    {
        interface Bar
        {
            void method(int param1, out string param2);
        }
    };

The generated callback class that would result for the method would
be named Foo.AMI_Bar_method and the user would have to implement a 
callback class similar to the following:

    class AMI_Bar_methodI : Foo.AMI_Bar_method
    {
        public override void ice_response(string param2)
        {
            // Called on success
            ...
        }

        public override void ice_exception(Ice.Exception ex)
        {
            // Called on failure
            ...
        }
    }

The method invocation would then look like the following:


    public void someFunction()
    {
        ...

        Foo.BarPrx proxy = ... // Obtain proxy by regular means
        proxy.method_async(new AMI_Bar_methodI(), 0);

        ...
    }

Ice for Silverlight uses C# delegates to implement the callbacks now
instead of the callback class. A callback class instance is no longer
passed to the asynchronous call Instead two delegate functions are
passed, one for the response callback and one for the exception 
callback. The signatures for these methods are the same as those for
the ice_response() and ice_exception() methods in Ice for C#.

Therefore using the same slice as above, for Ice for Silverlight the
AMI call could be implemented similar to the following:

    public void methodResponse(string param2)
    {
        // Called on success
        ...
    }

    public void methodException(Ice.Exception ex)
    {
        // Called on failure
        ...
    }

    public void someFunction()
    {
        ...

        Foo.BarPrx proxy = ... // Obtain proxy by regular means
        proxy.method_async(methodResponse, methodException, 0);

        ...
    }


User Exceptions and Object-by-Value
-----------------------------------

Ice for .NET supports user exceptions and objects by value through
reflection. Unfortunately, Silverlight does not support
AppDomain.CurrentDomain.GetAssemblies(), which means that the user
exception and objects types that are received by value must reside
in the same assembly as the Ice for Silverlight runtime. If the
type cannot be found by the Ice for Silverlight runtime an
Ice.UnmarshalOutOfBounds exception will be raised.

The easiest way to ensure that the Ice for Silverlight runtime can
find the relevant types is to merge the IceSL.dll assembly with
your application code assembly. This can be done using the ILMerge
tool provided by Microsoft. Please see the link below for more
information:

  http://research.microsoft.com/~mbarnett/ILMerge.aspx
