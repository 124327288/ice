// **********************************************************************
//
// Copyright (c) 2003-2006 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

#include <EmpI.h>
#include <Util.h>
#include <sqlca.h>

EXEC SQL WHENEVER SQLERROR DO handleSqlError(sqlca, ctx);

using namespace std;


EmpI::EmpI(const CurrentSqlContext& currentCtx,
	   const string& empCategory, const string& deptCategory) :
    _currentCtx(currentCtx), 
    _empCategory(empCategory), _deptCategory(deptCategory)
{
}

void 
EmpI::ice_ping(const Ice::Current& current) const
{
    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;
    sql_context ctx = _currentCtx;
    int empno = decodeName(current.id.name);
    int count = 0;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONTEXT USE :ctx;
    EXEC SQL SELECT COUNT(*) INTO :count FROM EMP WHERE EMPNO = :empno;
    EXEC SQL COMMIT;

    if(count == 0)
    {
	throw Ice::ObjectNotExistException(__FILE__, __LINE__);
    }
}


HR::EmpDesc 
EmpI::getDesc(const Ice::Current& current)
{
    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;
    sql_context ctx = _currentCtx;
    int empno = decodeName(current.id.name);
    char ename[21];
    short enameInd;
    char job[10];
    short jobInd;
    int mgr;
    short mgrInd;
    char hiredate[30];
    short hiredateInd;
    char sal[11];
    short salInd;
    char comm[11];
    short commInd;
    int deptno;
    short deptnoInd;
    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL CONTEXT USE :ctx;
    EXEC SQL SELECT ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO 
	     INTO :ename:enameInd, :job:jobInd, :mgr:mgrInd, 
	          :hiredate:hiredateInd, :sal:salInd, :comm:commInd, :deptno:deptnoInd
             FROM EMP WHERE EMPNO = :empno;
    EXEC SQL COMMIT;
    
    HR::EmpDesc result;
    if(enameInd >= 0)
    {
	result.ename = ename;
    }
    if(jobInd >= 0)
    {
	result.job = job;
    }
    if(mgrInd >= 0)
    {
	Ice::Identity mgrId;
	mgrId.name = encodeName(mgr);
	mgrId.category = _empCategory;
	result.mgr = HR::EmpPrx::uncheckedCast(current.adapter->createProxy(mgrId));
    }
    if(hiredateInd >= 0)
    {
	result.hiredate = hiredate;
    }
    if(salInd >= 0)
    {
	result.sal = sal;
    }
    if(commInd >= 0)
    {
	result.comm = comm;
    }
    if(deptnoInd >= 0)
    {
	Ice::Identity deptId;
	deptId.name = encodeName(deptno);
	deptId.category = _deptCategory;
	result.edept = HR::DeptPrx::uncheckedCast(current.adapter->createProxy(deptId));
    }
    return result;
}
    
void EmpI::updateDesc(const HR::EmpDesc& newDesc, const Ice::Current& current)
{
    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;
    sql_context ctx = _currentCtx;
    int empno = decodeName(current.id.name);
    const char* ename = newDesc.ename.c_str();
    const char* job = newDesc.job.c_str();
    int mgr = 0;
    short mgrInd = 0;
    const char* hiredate = newDesc.hiredate.c_str();
    const char* sal = newDesc.sal.c_str();
    const char* comm = newDesc.comm.c_str();
    int deptno = 0;
    short deptnoInd = 0;
    EXEC SQL END DECLARE SECTION;
    if(newDesc.mgr == 0)
    {
	mgrInd = -1;
    }
    else
    {
	mgr = decodeName(newDesc.mgr->ice_getIdentity().name);
    }
    if(newDesc.edept == 0)
    {
	deptnoInd = -1;
    }
    else
    {
	deptno = decodeName(newDesc.edept->ice_getIdentity().name);
    }

    EXEC SQL CONTEXT USE :ctx;
    EXEC SQL UPDATE EMP
             SET ENAME = :ename, JOB = :job, MGR = :mgr:mgrInd, HIREDATE = :hiredate,
	         SAL = :sal, COMM = :comm, DEPTNO = :deptno:deptnoInd
             WHERE EMPNO = :empno;
    EXEC SQL COMMIT;
}

void EmpI::remove(const Ice::Current& current)
{
    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;
    sql_context ctx = _currentCtx;
    int empno = decodeName(current.id.name);
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONTEXT USE :ctx;
    EXEC SQL DELETE FROM EMP WHERE EMPNO = :empno;
    EXEC SQL COMMIT;
}

