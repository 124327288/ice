// **********************************************************************
//
// Copyright (c) 2003-2006 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

#include <IceUtil/DisableWarnings.h>
#include <IceUtil/Functional.h>
#include <Gen.h>

#include <sys/types.h>
#include <sys/stat.h>

#ifdef _WIN32
#include <direct.h>
#else
#include <unistd.h>
#endif

#ifdef __BCPLUSPLUS__
#  include <iterator>
#endif

using namespace std;
using namespace Slice;
using namespace IceUtil;

namespace Slice
{

void
generate(const UnitPtr& unit, const ::std::string& dir,
	 const ::std::string& header, const ::std::string& footer, unsigned indexCount)
{
    unit->mergeModules();

    //
    // I don't want the top-level module to be sorted, therefore no
    // p->sort() before or after the p->sortContents().
    //
    unit->sortContents(false);

    GeneratorBase::setOutputDir(dir);
    GeneratorBase::setHeader(header);
    GeneratorBase::setFooter(footer);
    GeneratorBase::setIndexCount(indexCount);

    //
    // The types visitor first runs over the tree and records
    // the names of all files in this documentation set.
    // This information is used later to check whether a referenced
    // symbol is defined in this documentation set (as opposed to
    // being defined in an included fiel that is not part of this
    // documentation set. If the former, we can generate a link
    // to the symbol; if the latter, we cannot.
    //
    Files files;
    TypesVisitor tv(files);
    unit->visit(&tv, false);

    //
    // Generate the main module index.
    //
    IndexVisitor iv(files);
    unit->visit(&iv, false);

    //
    // Generate the individual HTML pages.
    //
    Visitor v(files);
    unit->visit(&v, false);
}

}

string Slice::GeneratorBase::_dir = ".";
string Slice::GeneratorBase::_header1;
string Slice::GeneratorBase::_header2;
string Slice::GeneratorBase::_footer;
unsigned Slice::GeneratorBase::_indexCount = 0;

//
// Set the output directory, creating it if necessary.
//

void
Slice::GeneratorBase::setOutputDir(const string& dir)
{
    if(!dir.empty())
    {
	_dir = dir;
	makeDir(_dir);
    }
}

//
// Set a header. If "header" is empty, use a default header.
// If a header file is specified, it is expected to end in <body>
// and to contain a "TITLE" placeholder line (in column 1, no leading
// or trailing white space). The actual document title is later substituted
// where that TITLE placeholder appears.
//

void
Slice::GeneratorBase::setHeader(const string& header)
{
    if(header.empty())
    {
	ostringstream hdr1;
	XMLOutput O1(hdr1);
	O1 << "<!-- Generated by Ice version " << ICE_STRING_VERSION << " -->";
	O1 << sp;
	O1 << nl << "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">";
	O1 << se("html");
	O1 << se("head");
	O1 << se("title") << nl;
	_header1 = hdr1.str();

	// _header1 and _header2 store the bit preceding and following the title.
	// _header1, the title text, and _header2 are written by openDoc().

	ostringstream hdr2;
	XMLOutput O2(hdr2);
	O2.inc();
	O2.inc();
	O2 << nl << "</title>";
	O2.dec();
	O2 << nl << "</head>";
	O2 << nl << "<body>";
	_header2 = hdr2.str();
    }
    else
    {
	readFile(header, _header1, _header2);
    }
}

//
// Set a footer. If "footer" is empty, use a default footer.
// The footer is expected to start with </body>.
//

void
Slice::GeneratorBase::setFooter(const string& footer)
{
    ostringstream ftr;
    XMLOutput O(ftr);
    if(footer.empty())
    {
	O << "    </body>";
    }
    else
    {
	O << readFile(footer);
    }
    O << nl << "</html>";
    _footer = ftr.str();
}

//
// Set the threshold at which we start generating sub-indexes.
// If a page has fewer entries than this, we don't generate a
// sub-index. (For example, with "ic" set to 3, we generate
// a sub-index only if, say, a structure has 3 or more members.
//

void
Slice::GeneratorBase::setIndexCount(int ic)
{
    _indexCount = ic;
}

Slice::GeneratorBase::GeneratorBase(XMLOutput& o, const Files& files)
    : _out(o), _files(files)
{
}

Slice::GeneratorBase::~GeneratorBase()
{
}

//
// Open a file for writing in the output directory (the output directory
// is created if necessary) and write the HTML header into the file.
//

void
Slice::GeneratorBase::openDoc(const string& file, const string& title)
{
    makeDir(_dir);
    openStream(_dir + "/" + file);

    _out << _header1;
    _out << title;
    _out << _header2;
    _out.inc();
    _out.inc();
}

//
// Open an HTML file for writing for the specified construct. The
// path name of the file is relative to the output directory and
// is constructed from the Slice scoped name. Sub-directories are
// created as needed and the header is written to the file.
//

void
Slice::GeneratorBase::openDoc(const ContainedPtr& c)
{
    string path = _dir;
    StringList components = getContainer(c);
    StringList::size_type num = 0;
    for(StringList::const_iterator i = components.begin(); i != components.end(); ++i)
    {
	path += "/" + *i;
	++num;
	if(num < components.size())
	{
	    makeDir(path);
	}
    }
    path += ".html";

    openStream(path);

    _out << _header1;
    _out << c->scoped().substr(2); // Text for title element.
    _out << _header2;
    _out.inc();
    _out.inc();
}

//
// Close an open HTML file after writing the footer.
//

void
Slice::GeneratorBase::closeDoc()
{
    _out.dec();
    _out.dec();
    _out << nl << _footer;
    _out << nl;
}

void
Slice::GeneratorBase::start(const std::string& element, const std::string& classes)
{
    string s = element;
    if(!classes.empty())
    {
	s += " class=\"" + classes + "\"";
    }
    _out << se(s);
}

void
Slice::GeneratorBase::end()
{
    _out << ee;
}

void
Slice::GeneratorBase::printComment(const ContainedPtr& p, const string& deprecateReason, bool inIndex)
{
#ifndef NDEBUG
    int indent = _out.currIndent();
#endif

    ContainerPtr container = ContainerPtr::dynamicCast(p);
    if(!ContainerPtr::dynamicCast(p))
    {
	container = p->container();
    }
    string comment = getComment(p, container, false, inIndex);
    StringList par = getTagged("param", comment);
    StringList ret = getTagged("return", comment);
    StringList throws = getTagged("throws", comment);
    StringList see = getTagged("see", comment);

    string::size_type pos = comment.find_last_not_of(" \t\r\n");
    if(pos != string::npos)
    {
	comment.erase(pos + 1);
	start("p");
	_out.zeroIndent();
	_out << nl << comment;
	_out.restoreIndent();
	end();
    }

    if(!deprecateReason.empty())
    {
	start("p");
	_out << nl << deprecateReason;
	end();
    }

    assert(_out.currIndent() == indent);

    if(!par.empty())
    {
	start("h4");
	_out << "Parameters";
	end();
	start("dl");
	for(StringList::const_iterator q = par.begin(); q != par.end(); ++q)
	{
	    string term;
	    pos = q->find_first_of(" \t\r\n");
	    if(pos != string::npos)
	    {
		term = q->substr(0, pos);
	    }
	    string item;
	    pos = q->find_first_not_of(" \t\r\n", pos);
	    if(pos != string::npos)
	    {
		item = q->substr(pos);
	    }
	    
	    start("dt", "Symbol");
	    _out << term;
	    end();
	    start("dd");
	    _out << nl << item;
	    end();
	}
	end();
    }

    if(!ret.empty())
    {
	start("h4");
	_out << "Return Value";
	end();
	start("p", "Symbol");
	_out << ret.front();
	end();
    }

    if(!throws.empty())
    {
	start("h4");
	_out << "Exceptions";
	end();
	start("dl");
	for(StringList::const_iterator q = throws.begin(); q != throws.end(); ++q)
	{
	    string term;
	    pos = q->find_first_of(" \t\r\n");
	    if(pos != string::npos)
	    {
		term = q->substr(0, pos);
	    }
	    string item;
	    pos = q->find_first_not_of(" \t\r\n", pos);
	    if(pos != string::npos)
	    {
		item = q->substr(pos);
	    }
	    
	    start("dt", "Symbol");
	    _out << toString(term, container, false, inIndex);
	    end();
	    start("dd");
	    _out << nl << item;
	    end();
	}
	end();
    }

    ClassList derivedClasses;
    ClassDefPtr def = ClassDefPtr::dynamicCast(p);
    if(def)
    {
	derivedClasses = p->unit()->findDerivedClasses(def);
    }
    if(!derivedClasses.empty())
    {
	start("h4", "Heading");
	_out << "Derived Classes and Interfaces";
	end();
	start("dl");
	for(ClassList::const_iterator q = derivedClasses.begin(); q != derivedClasses.end(); ++q)
	{
	    start("dt", "Symbol");
	    _out << toString(*q, container, false, inIndex);
	    end();
	}
	end();
    }

    ExceptionList derivedExceptions;
    ExceptionPtr ex = ExceptionPtr::dynamicCast(p);
    if(ex)
    {
	derivedExceptions = p->unit()->findDerivedExceptions(ex);
	if(!derivedExceptions.empty())
	{
	    start("h4");
	    _out << "Derived Exceptions";
	    end();
	    start("dl");
	    for(ExceptionList::const_iterator q = derivedExceptions.begin(); q != derivedExceptions.end(); ++q)
	    {
		start("dt", "Symbol");
		_out << toString(*q, container, false, inIndex);
		end();
	    }
	    end();
	}

	ContainedList usedBy;
	usedBy = p->unit()->findUsedBy(ex);
	if(!usedBy.empty())
	{
	    start("h4", "Heading");
	    _out << "Used By";
	    end();
	    start("dl", "UsedBy");
	    //
	    // We first extract the symbol names from the used-by list and sort
	    // them, otherwise the symbols appear in random order.
	    //
	    StringList sl;
	    for(ContainedList::const_iterator q = usedBy.begin(); q != usedBy.end(); ++q)
	    {
		sl.push_back(toString(*q, container, false, inIndex));
	    }
	    sl.sort();
	    for(StringList::const_iterator r = sl.begin(); r != sl.end(); ++r)
	    {
		start("dt", "Symbol");
		_out << *r;
		end();
	    }
	    end();
	}
    }

    ContainedList usedBy;
    ConstructedPtr constructed;
    if(def)
    {
	constructed = def->declaration();
    }
    else
    {
	constructed = ConstructedPtr::dynamicCast(p);
    }
    if(constructed)
    {
	usedBy = p->unit()->findUsedBy(constructed);
    }
    if(!usedBy.empty())
    {
	//
	// We first accumulate the strings in a list instead of printing
	// each stringified entry in the usedBy list. This is necessary because
	// the usedBy list can contain operations and parameters. But toString()
	// on a parameter returns the string for the parameter's operation, so
	// we can end up printing the same operation name more than once.
	//
	StringList strings;
	for(ContainedList::const_iterator q = usedBy.begin(); q != usedBy.end(); ++q)
	{
	    strings.push_back(toString(*q, container, false, inIndex));
	}
	strings.sort();
	strings.unique();

	start("h4", "Heading");
	_out << "Used By";
	end();
	start("dl", "UsedBy");
	for(list<string>::const_iterator p = strings.begin(); p != strings.end(); ++p)
	{
	    start("dt", "Symbol");
	    _out << *p;
	    end();
	}
	end();
    }

    if(!see.empty())
    {
	start("h4");
	_out << "See Also";
	end();
	start("dl", "UsedBy");
	for(StringList::const_iterator q = see.begin(); q != see.end(); ++q)
	{
	    start("dt", "Symbol");
	    _out << toString(*q, container, false, inIndex);
	    end();
	}
	end();
    }

    assert(_out.currIndent() == indent);
}

void
Slice::GeneratorBase::printMetaData(const ContainedPtr& p)
{
    list<string> metaData = p->getMetaData();

    if(!metaData.empty())
    {
	_out << "[";
	list<string>::const_iterator q = metaData.begin();
	while(q != metaData.end())
	{
	    _out << " \"" << *q << "\"";
	    if(++q != metaData.end())
	    {
		_out << ",";
	    }
	}
	_out << " ]" << nl;
    }
}

void
Slice::GeneratorBase::printSummary(const ContainedPtr& p, const ContainerPtr& module, bool deprecated)
{
    ContainerPtr container = ContainerPtr::dynamicCast(p);
    if(!container)
    {
	container = p->container();
    }

    if(module)
    {
	container = module;
    }

    string summary = getComment(p, container, true, module);
    start("dd", "Summary");
    _out << nl << summary;
    end();

    if(deprecated)
    {
	start("dd", "Deprecated");
	_out << nl << "Deprecated.";
	end();
    }
}

string
Slice::GeneratorBase::toString(const SyntaxTreeBasePtr& p, const ContainerPtr& container, bool asTarget, bool inIndex)
{
    string anchor;
    string linkpath;
    string s;

    static const char* builtinTable[] =
    {
	"byte",
	"bool",
	"short",
	"int",
	"long",
	"float",
	"double",
	"string",
	"Object",
	"Object*",
	"LocalObject"
    };

    BuiltinPtr builtin = BuiltinPtr::dynamicCast(p);
    if(builtin)
    {
	s = builtinTable[builtin->kind()];
	return s;
    }

    ProxyPtr proxy = ProxyPtr::dynamicCast(p);
    if(proxy)
    {
	if(_files.find(p->definitionContext()->filename()) != _files.end())
	{
	    anchor = getAnchor(proxy->_class()->definition());
	    linkpath = getLinkPath(proxy->_class()->definition(), container, inIndex);
	}
	s = getScopedMinimized(proxy->_class(), container);
    }

    ClassDeclPtr cl = ClassDeclPtr::dynamicCast(p);
    if(cl)
    {
	//
        // We must generate the id from the definition, not from the
        // declaration, provided that a definition is available.
	//
	ContainedPtr definition = cl->definition();
	if(definition && _files.find(p->definitionContext()->filename()) != _files.end())
	{
	    anchor = getAnchor(definition);
	    linkpath = getLinkPath(definition, container, inIndex);
	}
	s = getScopedMinimized(cl, container);
    }

    ExceptionPtr ex = ExceptionPtr::dynamicCast(p);
    if(ex)
    {
	if(_files.find(p->definitionContext()->filename()) != _files.end())
	{
	    anchor = getAnchor(ex);
	    linkpath = getLinkPath(ex, container, inIndex);
	}
	s = getScopedMinimized(ex, container);
    }

    StructPtr st = StructPtr::dynamicCast(p);
    if(st)
    {
	if(_files.find(p->definitionContext()->filename()) != _files.end())
	{
	    anchor = getAnchor(st);
	    linkpath = getLinkPath(st, container, inIndex);
	}
	s = getScopedMinimized(st, container);
    }

    EnumeratorPtr en = EnumeratorPtr::dynamicCast(p);
    if(en)
    {
	if(_files.find(p->definitionContext()->filename()) != _files.end())
	{
	    anchor = getAnchor(en);
	    linkpath = getLinkPath(en, container, inIndex);
	}
	s = getScopedMinimized(en, container);
    }

    OperationPtr op = OperationPtr::dynamicCast(p);
    if(op)
    {
	if(_files.find(p->definitionContext()->filename()) != _files.end())
	{
	    anchor = getAnchor(op);
	    linkpath = getLinkPath(op, container, inIndex);
	}
	s = getScopedMinimized(op, container);
    }

    ParamDeclPtr pd = ParamDeclPtr::dynamicCast(p);
    if(pd)
    {
	op = OperationPtr::dynamicCast(pd->container());
	assert(op);
	if(_files.find(p->definitionContext()->filename()) != _files.end())
	{
	    anchor = getAnchor(op);
	    linkpath = getLinkPath(op, container, inIndex);
	}
	s = getScopedMinimized(op, container);
    }
    
    if(s.empty())
    {
	ContainedPtr contained = ContainedPtr::dynamicCast(p);
	assert(contained);
	if(_files.find(p->definitionContext()->filename()) != _files.end())
	{
	    anchor = getAnchor(contained);
	    //
	    // Sequences and dictionaries are documented on the page for their
	    // enclosing module.
	    //
	    if(SequencePtr::dynamicCast(p) || DictionaryPtr::dynamicCast(p))
	    {
		linkpath = getLinkPath(contained->container(), container, inIndex);
	    }
	    else
	    {
		linkpath = getLinkPath(contained, container, inIndex);
	    }
	}
	s = getScopedMinimized(contained, container);
    }

    if(linkpath.empty() && anchor.empty())
    {
	if(ProxyPtr::dynamicCast(p))
	{
	    s += '*';
	}
	return s;
    }

    string ret = "<a ";
    ret += (asTarget ? "name" : "href");
    ret += "=\"";
    if(asTarget)
    {
	ret += anchor;
    }
    else
    {
	ret += linkpath;
	if(!linkpath.empty())
	{
	    ret += ".html";
	}
	if(!anchor.empty())
	{
	    ret += "#" + anchor;
	}
    }
    ret += "\">";
    ret += s;
    ret += "</a>";
    if(ProxyPtr::dynamicCast(p))
    {
	ret += '*';
    }
    return ret;
}

string
Slice::GeneratorBase::toString(const string& str, const ContainerPtr& container, bool asTarget, bool inIndex)
{
    string s = str;

    TypeList types = container->lookupType(s, false);
    if(!types.empty())
    {
	return toString(types.front(), container, asTarget, inIndex);
    }

    ContainedList contList = container->lookupContained(s, false);
    if(!contList.empty())
    {
	return toString(contList.front(), container, asTarget, inIndex);
    }

    //
    // If we can't find the string, printing it in typewriter
    // font is the best we can do.
    //
    return "<tt>" + s + "</tt>";
}

string
Slice::GeneratorBase::getComment(const ContainedPtr& contained, const ContainerPtr& container,
				 bool summary, bool inIndex)
{
    string s = contained->comment();
    string comment;
    for(unsigned int i = 0; i < s.size(); ++i)
    {
	if(s[i] == '\\' && i + 1 < s.size() && s[i + 1] == '[')
	{
	    comment += '[';
	    ++i;
	}
	else if(s[i] == '[')
	{
	    string literal;
	    for(++i; i < s.size(); ++i)
	    {
		if(s[i] == ']')
		{
		    break;
		}
		
		literal += s[i];
	    }
	    comment += toString(literal, container, false, inIndex);
	}
	else if(summary && s[i] == '.' && (i + 1 >= s.size() || isspace(s[i + 1])))
	{
	    comment += '.';
	    break;
	}
	else
	{
	    comment += s[i];
	}

    }
    return comment;
}

string
Slice::GeneratorBase::getAnchor(const SyntaxTreeBasePtr& p)
{
    StringList symbols = getContained(p);
    string anchor;
    for(StringList::const_iterator i = symbols.begin(); i != symbols.end(); ++i)
    {
	if(i != symbols.begin())
	{
	    anchor += "::";
	}
	anchor += *i;
    }
    return anchor;
}

string
Slice::GeneratorBase::getLinkPath(const SyntaxTreeBasePtr& p, const ContainerPtr& container, bool inIndex)
{
    ContainerPtr c = container;

    //
    // If we are in a sub-index, we need to "step up" one level, because the links all
    // point at a section in the same file.
    //
    if(inIndex)
    {
	if(ContainedPtr::dynamicCast(container))
	{
	    c = ContainedPtr::dynamicCast(c)->container();
	}
    }

    //
    // Find the first component where the two scopes differ.
    //
    bool commonEnclosingScope = false;
    StringList target = getContainer(p);
    StringList from = getContainer(c);
    while(!target.empty() && !from.empty() && target.front() == from.front())
    {
	target.pop_front();
	from.pop_front();
	commonEnclosingScope = true;
    }

    if(commonEnclosingScope && target.empty())
    {
	ModulePtr module = ModulePtr::dynamicCast(p);
	if(module)
	{
	    target.push_front(module->name());
	}
    }
    else if(!from.empty())
    {
	from.pop_front();
    }

    //
    // For each component in the source path, step up a level.
    //
    string path;
    while(!from.empty())
    {
	if(!path.empty())
	{
	    path += "/";
	}
	path += "..";
	from.pop_front();
    }

    //
    // Now append the scope to the target.
    //
    while(!target.empty())
    {
	if(!path.empty())
	{
	    path += "/";
	}
	path += target.front();
	target.pop_front();
    }
    return path;
}

void
Slice::GeneratorBase::openStream(const string& path)
{
    _out.open(path.c_str());
    if(!_out.isOpen())
    {
	string err = "cannot open `" + path + "' for writing";
	throw err;
    }
}

string
Slice::GeneratorBase::containedToId(const ContainedPtr& contained, bool asTarget)
{
    assert(contained);

    string scoped = contained->scoped();
    if(scoped[0] == ':')
    {
	scoped.erase(0, 2);
    }

    string id;
    id.reserve(scoped.size());

    for(unsigned int i = 0; i < scoped.size(); ++i)
    {
	if(scoped[i] == ':')
	{
	    id += '.';
	    ++i;
	}
	else
	{
	    id += scoped[i];
	}
    }

    //
    // A link name cannot start with a period.
    //
    if(id[0] == '.')
    {
	id.erase(0, 1);
    }

    return '"' + id + '"';
}

StringList
Slice::GeneratorBase::getTagged(const string& tag, string& comment)
{
    StringList result;
    string::size_type begin = 0;
    while(begin < comment.size())
    {
	begin = comment.find("@" + tag, begin);
	if(begin == string::npos)
	{
	    return result;
	}
	
	string::size_type pos1 = comment.find_first_not_of(" \t\r\n", begin + tag.size() + 1);
	if(pos1 == string::npos)
	{
	    comment.erase(begin);
	    return result;
	}
	
	string::size_type pos2 = comment.find('@', pos1);
	string line = comment.substr(pos1, pos2 - pos1);
	comment.erase(begin, pos2 - 1 - begin);

	string::size_type pos3 = line.find_last_not_of(" \t\r\n");
	if(pos3 != string::npos)
	{
	    line.erase(pos3 + 1);
	}
	result.push_back(line);
    }

    return result;
}

string
Slice::GeneratorBase::getScopedMinimized(const ContainedPtr& contained, const ContainerPtr& container)
{
    string s = contained->scoped();
    ContainerPtr p = container;
    ContainedPtr q = ContainedPtr::dynamicCast(p);

    if(!q) // Container is the global module
    {
	return s.substr(2);
    }
    
    do
    {
	string s2 = q->scoped();
	s2 += "::";

	if(s.find(s2) == 0)
	{
	    return s.substr(s2.size());
	}

	p = q->container();
	q = ContainedPtr::dynamicCast(p);
    }
    while(q);

    return s;
}

StringList
Slice::GeneratorBase::getContained(const SyntaxTreeBasePtr& p)
{
    StringList result;
    if(!p)
    {
	return result;
    }

    SyntaxTreeBasePtr c = p;

    do
    {
	ContainedPtr contained = ContainedPtr::dynamicCast(c);
	assert(contained);
	result.push_front(contained->name());
	c = contained->container();
    }
    while(!ContainerPtr::dynamicCast(c));
    return result;
}

StringList
Slice::GeneratorBase::getContainer(const SyntaxTreeBasePtr& p)
{
    StringList result;

    if(!p)
    {
	return result;
    }

    ContainedPtr contained = ContainedPtr::dynamicCast(p);
    while(contained &&
	  !ModulePtr::dynamicCast(contained) &&
	  !ExceptionPtr::dynamicCast(contained) &&
	  !ClassDefPtr::dynamicCast(contained) &&
	  !StructPtr::dynamicCast(contained) &&
	  !EnumPtr::dynamicCast(contained))
    {
	contained = ContainedPtr::dynamicCast(contained->container());
    }

    while(contained)
    {
	result.push_front(contained->name());
	contained = ContainedPtr::dynamicCast(contained->container());
    }
    return result;
}

StringList
Slice::GeneratorBase::toStringList(const ContainedPtr& c)
{
    string scoped = c->scoped();
    assert(scoped.size() > 2);
    assert(scoped[0] == ':');
    assert(scoped[1] == ':');

    StringList ids;
    string::size_type next = 2;
    string::size_type endpos;
    while((endpos = scoped.find("::", next)) != string::npos)
    {
	ids.push_back(scoped.substr(next, endpos - next));
	next = endpos;
	if(next != string::npos)
	{
	    ++next;
	    ++next;
	}
    }
    ids.push_back(scoped.substr(next));

    return ids;
}

void
Slice::GeneratorBase::makeDir(const string& dir)
{
    struct stat st;
    int rc = stat(dir.c_str(), &st);
    if(rc == 0)
    {
	return;
    }
#ifdef _WIN32
    rc = mkdir(dir.c_str());
#else
    rc = mkdir(dir.c_str(), S_IRWXU | S_IRWXG | S_IRWXO);
#endif
    if(rc != 0)
    {
	string err = "cannot create directory `" + dir + "'";
	throw err;
    }
}

string
Slice::GeneratorBase::readFile(const string& file)
{
    ifstream in(file.c_str());
    if(!in)
    {
	string err = "cannot open `" + file + "' for reading";
	throw err;
    }

    ostringstream result;
    string line;
    getline(in, line);
    while(!line.empty())
    {
	result << line << '\n';
	getline(in, line);
    }
    
    return result.str();
}

void
Slice::GeneratorBase::readFile(const string& file, string& part1, string& part2)
{
    ifstream in(file.c_str());
    if(!in)
    {
	string err = "cannot open `" + file + "' for reading";
	throw err;
    }

    string line;

    ostringstream p1;
    getline(in, line);
    while(!line.empty() && line != "TITLE")
    {
	p1 << line << '\n';
	getline(in, line);
    }
    part1 = p1.str();

    if(line.empty())
    {
	string err = "no TITLE marker in `" + file + "'";
	throw err;
    }

    ostringstream p2;
    p2 << endl;
    getline(in, line);
    while(!line.empty())
    {
	p2 << line << '\n';
	getline(in, line);
    }
    part2 = p2.str();
}

Slice::IndexGenerator::IndexGenerator(const Files& files)
    : GeneratorBase(_out, files)
{
    openDoc("index.html", "Slice Documentation Index");
}

Slice::IndexGenerator::~IndexGenerator()
{
    ::std::sort(_modules.begin(), _modules.end());

    start("h1");
    _out << "Slice Documentation Index";
    end();
    start("h2");
    _out << "Modules";
    end();
    start("dl");
    for(ModuleDescriptions::const_iterator i = _modules.begin(); i != _modules.end(); ++i)
    {
	start("dt");
	_out << i->first;
	end();
	start("dd");
	_out << i->second;
	end();
    }
    end();

    closeDoc();
}

void
Slice::IndexGenerator::generate(const ModulePtr& m)
{
    string name = toString(m, 0, false);
    string comment = getComment(m, 0, true);
    _modules.push_back(make_pair(name, comment));
}

Slice::TypesVisitor::TypesVisitor(Files& files)
    : _files(files)
{
}

bool
Slice::TypesVisitor::visitUnitStart(const UnitPtr& u)
{
    return true;
}

bool
Slice::TypesVisitor::visitModuleStart(const ModulePtr& m)
{
    _files.insert(m->definitionContext()->filename());
    return true;
}

bool
Slice::TypesVisitor::visitExceptionStart(const ExceptionPtr& e)
{
    _files.insert(e->definitionContext()->filename());
    return false;
}

bool
Slice::TypesVisitor::visitClassDefStart(const ClassDefPtr& c)
{
    _files.insert(c->definitionContext()->filename());
    return false;
}

void
Slice::TypesVisitor::visitClassDecl(const ClassDeclPtr& c)
{
    _files.insert(c->definitionContext()->filename());
}

bool
Slice::TypesVisitor::visitStructStart(const StructPtr& s)
{
    _files.insert(s->definitionContext()->filename());
    return false;
}

void
Slice::TypesVisitor::visitSequence(const SequencePtr& s)
{
    _files.insert(s->definitionContext()->filename());
}

void
Slice::TypesVisitor::visitDictionary(const DictionaryPtr& d)
{
    _files.insert(d->definitionContext()->filename());
}

void
Slice::TypesVisitor::visitEnum(const EnumPtr& e)
{
    _files.insert(e->definitionContext()->filename());
}

Slice::IndexVisitor::IndexVisitor(const Files& files)
    : _ig(files)
{
}

bool
Slice::IndexVisitor::visitUnitStart(const UnitPtr& unit)
{
    return true;
}

bool
Slice::IndexVisitor::visitModuleStart(const ModulePtr& m)
{
    _ig.generate(m);
    return false;
}

Slice::ModuleGenerator::ModuleGenerator(XMLOutput& o, const Files& files)
    : GeneratorBase(o, files)
{
}

void
Slice::ModuleGenerator::generate(const ModulePtr& m)
{
#ifndef NDEBUG
    int indent = _out.currIndent();
#endif

    openDoc(m);

    start("h1", "Symbol");
    _out << toString(m, m, true);
    end();

    string metadata, deprecateReason;
    if(m->findMetaData("deprecate", metadata))
    {
	deprecateReason = "This module is deprecated.";
	if(metadata.find("deprecate:") == 0 && metadata.size() > 10)
	{
	    deprecateReason = metadata.substr(10);
	}
    }
    start("h2");
    _out << "Overview";
    end();
    start("h3", "Synopsis");
    printMetaData(m);
    _out << "module " << m->name();
    end();

    printComment(m, deprecateReason, true);

    visitContainer(m);

    closeDoc();

    assert(_out.currIndent() == indent);
}

void
Slice::ModuleGenerator::visitContainer(const ContainerPtr& p)
{
#ifndef NDEBUG
    int indent = _out.currIndent();
#endif

    ModuleList modules = p->modules();

    if(!modules.empty())
    {
	start("h2");
	_out << "Module Index";
	end();
	start("dl");
	for(ModuleList::const_iterator q = modules.begin(); q != modules.end(); ++q)
	{
	    start("dt", "Symbol");
	    _out << toString(*q, p, false, true);
	    end();
	    start("dd");
	    string metadata;
	    printSummary(*q, p, (*q)->findMetaData("deprecate", metadata));
	    end();
	}
	end();
    }

    assert(_out.currIndent() == indent);

    ClassList classesAndInterfaces = p->classes();
    ClassList classes;
    ClassList interfaces;
    remove_copy_if(classesAndInterfaces.begin(), classesAndInterfaces.end(), back_inserter(classes),
		   ::IceUtil::constMemFun(&ClassDef::isInterface));
    remove_copy_if(classesAndInterfaces.begin(), classesAndInterfaces.end(), back_inserter(interfaces),
		   not1(::IceUtil::constMemFun(&ClassDef::isInterface)));

    if(!classes.empty())
    {
	start("h2");
	_out << "Class Index";
	end();
	start("dl");
	for(ClassList::const_iterator q = classes.begin(); q != classes.end(); ++q)
	{
	    start("dt", "Symbol");
	    _out << toString(*q, p, false, true);
	    end();
	    start("dd");
	    string metadata;
	    printSummary(*q, p, (*q)->findMetaData("deprecate", metadata));
	    end();
	}
	end();
    }

    assert(_out.currIndent() == indent);

    if(!interfaces.empty())
    {
	start("h2");
	_out << "Interface Index";
	end();
	start("dl");
	for(ClassList::const_iterator q = interfaces.begin(); q != interfaces.end(); ++q)
	{
	    start("dt", "Symbol");
	    _out << toString(*q, p, false, true);
	    end();
	    start("dd");
	    string metadata;
	    printSummary(*q, p, (*q)->findMetaData("deprecate", metadata));
	    end();
	}
	end();
    }

    assert(_out.currIndent() == indent);

    ExceptionList exceptions = p->exceptions();

    if(!exceptions.empty())
    {
	start("h2");
	_out << "Exception Index";
	end();
	start("dl");
	for(ExceptionList::const_iterator q = exceptions.begin(); q != exceptions.end(); ++q)
	{
	    start("dt", "Symbol");
	    _out << toString(*q, p, false, true);
	    end();
	    start("dd");
	    string metadata;
	    printSummary(*q, p, (*q)->findMetaData("deprecate", metadata));
	    end();
	}
	end();
    }

    assert(_out.currIndent() == indent);

    StructList structs = p->structs();

    if(!structs.empty())
    {
	start("h2");
	_out << "Structure Index";
	end();
	start("dl");
	for(StructList::const_iterator q = structs.begin(); q != structs.end(); ++q)
	{
	    start("dt", "Symbol");
	    _out << toString(*q, p, false, true);
	    end();
	    start("dd");
	    string metadata;
	    printSummary(*q, p, (*q)->findMetaData("deprecate", metadata));
	    end();
	}
	end();
    }

    assert(_out.currIndent() == indent);

    SequenceList sequences = p->sequences();

    if(!sequences.empty())
    {
	start("h2");
	_out << "Sequence Index";
	end();
	start("dl");
	for(SequenceList::const_iterator q = sequences.begin(); q != sequences.end(); ++q)
	{
	    start("dt", "Symbol");
	    _out << toString(*q, p, false, true);
	    end();
	    start("dd");
	    string metadata;
	    printSummary(*q, p, (*q)->findMetaData("deprecate", metadata));
	    end();
	}
	end();
    }

    assert(_out.currIndent() == indent);

    DictionaryList dictionaries = p->dictionaries();

    if(!dictionaries.empty())
    {
	start("h2");
	_out << "Dictionary Index";
	end();
	start("dl");
	for(DictionaryList::const_iterator q = dictionaries.begin(); q != dictionaries.end(); ++q)
	{
	    start("dt", "Symbol");
	    _out << toString(*q, p, false, true);
	    end();
	    start("dd");
	    string metadata;
	    printSummary(*q, p, (*q)->findMetaData("deprecate", metadata));
	    end();
	}
	end();
    }

    assert(_out.currIndent() == indent);

    EnumList enums = p->enums();

    if(!enums.empty())
    {
	start("h2");
	_out << "Enumeration Index";
	end();
	start("dl");
	for(EnumList::const_iterator q = enums.begin(); q != enums.end(); ++q)
	{
	    start("dt", "Symbol");
	    _out << toString(*q, p, false, true);
	    end();
	    start("dd");
	    string metadata;
	    printSummary(*q, p, (*q)->findMetaData("deprecate", metadata));
	    end();
	}
	end();
    }

    assert(_out.currIndent() == indent);

    if(!sequences.empty())
    {
	start("h2");
	_out << "Sequences";
	end();
	for(SequenceList::const_iterator q = sequences.begin(); q != sequences.end(); ++q)
	{
	    start("dl");
	    start("dt");
	    start("span", "Synopsis");
	    printMetaData(*q);
	    if((*q)->isLocal())
	    {
		_out << "local ";
	    }
	    TypePtr type = (*q)->type();
	    _out << "sequence&lt;" << toString(type, p, false, true) << "&gt; " << toString(*q, p);
	    end();
	    end();

	    start("dd");
	    string metadata, deprecateReason;
	    if((*q)->findMetaData("deprecate", metadata))
	    {
		deprecateReason = "This type is deprecated.";
		if(metadata.find("deprecate:") == 0 && metadata.size() > 10)
		{
		    deprecateReason = metadata.substr(10);
		}
	    }

	    printComment(*q, deprecateReason, true);
	    end();
	    end();
	}
    }

    if(!dictionaries.empty())
    {
	start("h2");
	_out << "Dictionaries";
	end();
	for(DictionaryList::const_iterator q = dictionaries.begin(); q != dictionaries.end(); ++q)
	{
	    start("dl");
	    start("dt");
	    start("span", "Synopsis");
	    printMetaData(*q);
	    if((*q)->isLocal())
	    {
		_out << "local ";
	    }
	    TypePtr keyType = (*q)->keyType();
	    TypePtr valueType = (*q)->valueType();
	    _out << "dictionary&lt;" << toString(keyType, p, false, true) << ", "
		 << toString(valueType, p, false, true) << "&gt; " << toString(*q, p);
	    end();
	    end();

	    start("dd");
	    string metadata, deprecateReason;
	    if((*q)->findMetaData("deprecate", metadata))
	    {
		deprecateReason = "This type is deprecated.";
		if(metadata.find("deprecate:") == 0 && metadata.size() > 10)
		{
		    deprecateReason = metadata.substr(10);
		}
	    }

	    printComment(*q, deprecateReason, true);
	    end();
	    end();
	}
    }
}

Slice::ExceptionGenerator::ExceptionGenerator(XMLOutput& o, const Files& files)
    : GeneratorBase(o, files)
{
}

void
Slice::ExceptionGenerator::generate(const ExceptionPtr& e)
{
#ifndef NDEBUG
    int indent = _out.currIndent();
#endif

    openDoc(e);

    start("h1", "Symbol");
    _out << toString(e, e, true);
    end();

    string metadata, deprecateReason;
    bool deprecatedException = e->findMetaData("deprecate", metadata);
    if(deprecatedException)
    {
	deprecateReason = "This module is deprecated.";
	if(metadata.find("deprecate:") == 0 && metadata.size() > 10)
	{
	    deprecateReason = metadata.substr(10);
	}
    }

    start("h2");
    _out << "Overview";
    end();

    start("h3", "Synopsis");
    printMetaData(e);
    if(e->isLocal())
    {
	_out << "local ";
    }
    _out << "exception " << e->name();
    ExceptionPtr base = e->base();
    if(base)
    {
	_out.inc();
	_out << nl << "extends ";
	_out.inc();
	_out << nl << toString(base, e);
	_out.dec();
	_out.dec();
    }
    end();

    printComment(e, deprecateReason);

    DataMemberList dataMembers = e->dataMembers();

    if(_indexCount > 0 && dataMembers.size() >= _indexCount)
    {
	start("h2");
	_out << "Data Member Index";
	end();
	start("dl");
	for(DataMemberList::const_iterator q = dataMembers.begin(); q != dataMembers.end(); ++q)
	{
	    start("dt", "Symbol");
	    _out << toString(*q, e, false);
	    end();
	    start("dd");
	    string metadata;
	    printSummary(*q, e, (*q)->findMetaData("deprecate", metadata));
	    end();
	}
	end();
    }

    if(!dataMembers.empty())
    {
	start("h2");
	_out << "Data Members";
	end();
	start("dl");
	for(DataMemberList::const_iterator q = dataMembers.begin(); q != dataMembers.end(); ++q)
	{
	    start("dt", "Symbol");
	    printMetaData(*q);
	    TypePtr type = (*q)->type();
	    _out << toString(type, e) << " " << toString(*q, e) << ";";
	    end();

	    start("dd");
	    string reason;
	    metadata.clear();
	    if(deprecatedException || (*q)->findMetaData("deprecate", metadata))
	    {
		reason = "This member is deprecated.";
		if(metadata.find("deprecate:") == 0 && metadata.size() > 10)
		{
		    reason = metadata.substr(10);
		}
	    }

	    printComment(*q, reason);
	    end();
	}
	end();
    }
	
    closeDoc();

    assert(_out.currIndent() == indent);
}

Slice::ClassGenerator::ClassGenerator(XMLOutput& o, const Files& files)
    : GeneratorBase(o, files)
{
}

void
Slice::ClassGenerator::generate(const ClassDefPtr& c)
{
#ifndef NDEBUG
    int indent = _out.currIndent();
#endif

    openDoc(c);

    start("h1", "Symbol");
    _out << toString(c, c, true);
    end();

    string metadata, deprecateReason;
    bool deprecatedClass = c->findMetaData("deprecate", metadata);
    if(deprecatedClass)
    {
	deprecateReason = "This ";
	deprecateReason += c->isInterface() ? "interface" : "class";
	deprecateReason += " is deprecated.";
	if(metadata.find("deprecate:") == 0 && metadata.size() > 10)
	{
	    deprecateReason = metadata.substr(10);
	}
    }

    start("h2");
    _out << "Overview";
    end();
    start("h3", "Synopsis");
    printMetaData(c);
    if(c->isLocal())
    {
	_out << "local ";
    }
    _out << (c->isInterface() ? "interface" : "class" )<< " " << c->name();

    ClassList bases = c->bases();
    if(!bases.empty() && !bases.front()->isInterface())
    {
	_out << " extends " << toString(bases.front(), c);
	bases.pop_front();
    }

    if(!bases.empty())
    {
	_out << (c->isInterface() ? " extends " : " implements ");
	ClassList::const_iterator q = bases.begin();
	while(q != bases.end())
	{
	    _out << toString(*q, c, false);
	    if(++q != bases.end())
	    {
		_out << ", ";
	    }
	}
    }
    end();

    printComment(c, deprecateReason);

    OperationList operations = c->operations();

    if(_indexCount > 0 && operations.size() >= _indexCount)
    {
	start("h2");
	_out << "Operation Index";
	end();
	start("dl");
	for(OperationList::const_iterator q = operations.begin(); q != operations.end(); ++q)
	{
	    start("dt", "Symbol");
	    _out << toString(*q, c, false);
	    end();
	    start("dd");
	    string metadata;
	    printSummary(*q, c, (*q)->findMetaData("deprecate", metadata));
	    end();
	}
	end();
    }

    DataMemberList dataMembers = c->dataMembers();

    if(_indexCount > 0 && dataMembers.size() >= _indexCount)
    {
	start("h2");
	_out << "Data Member Index";
	end();
	start("dl");
	for(DataMemberList::const_iterator q = dataMembers.begin(); q != dataMembers.end(); ++q)
	{
	    start("dt", "Symbol");
	    _out << toString(*q, c, false);
	    end();
	    start("dd");
	    string metadata;
	    printSummary(*q, c, (*q)->findMetaData("deprecate", metadata));
	    end();
	}
	end();
    }

    if(!operations.empty())
    {
	start("h2");
	_out << "Operations";
	end();
	for(OperationList::const_iterator q = operations.begin(); q != operations.end(); ++q)
	{
	    start("h3", "Synopsis");
	    TypePtr returnType = (*q)->returnType();
	    _out << (returnType ? toString(returnType, c, false) : string("void")) << " "
		 << toString(*q, c) << "(";
	    ParamDeclList params = (*q)->parameters();
	    ParamDeclList::const_iterator r = params.begin();
	    while(r != params.end())
	    {
		if((*r)->isOutParam())
		{
		    _out << "out ";
		}
		_out << toString((*r)->type(), ContainedPtr::dynamicCast(*q)->container(), false)
		     << " " << (*r)->name();
		if(++r != params.end())
		{
		    _out << ", ";
		}
	    }
	    _out << ")";
	    ExceptionList throws = (*q)->throws();
	    if(!throws.empty())
	    {
		_out << " throws ";
		ExceptionList::const_iterator t = throws.begin();
		while(t != throws.end())
		{
		    _out << toString(*t, c, false);
		    if(++t != throws.end())
		    {
			_out << ", ";
		    }
		}
	    }
	    end();

	    string reason;
	    metadata.clear();
	    if(deprecatedClass || (*q)->findMetaData("deprecate", metadata))
	    {
		reason = "This operation is deprecated.";
		if(metadata.find("deprecate:") == 0 && metadata.size() > 10)
		{
		    reason = metadata.substr(10);
		}
	    }
	    printComment(*q, reason);
	}
    }

    if(!dataMembers.empty())
    {
	start("h2");
	_out << "Data Members";
	end();
	for(DataMemberList::const_iterator q = dataMembers.begin(); q != dataMembers.end(); ++q)
	{
	    start("h3", "Synopsis");
	    printMetaData(*q);
	    TypePtr type = (*q)->type();
	    _out << toString(type, c, false) << " " << toString(*q, c) << ";";
	    end();

	    string reason;
	    metadata.clear();
	    if(deprecatedClass || (*q)->findMetaData("deprecate", metadata))
	    {
		reason = "This member is deprecated.";
		if(metadata.find("deprecate:") == 0 && metadata.size() > 10)
		{
		    reason = metadata.substr(10);
		}
	    }

	    printComment(*q, reason);
	}
    }

    closeDoc();

    assert(_out.currIndent() == indent);
}

Slice::StructGenerator::StructGenerator(XMLOutput& o, const Files& files)
    : GeneratorBase(o, files)
{
}

void
Slice::StructGenerator::generate(const StructPtr& s)
{
#ifndef NDEBUG
    int indent = _out.currIndent();
#endif

    openDoc(s);

    start("h1", "Symbol");
    _out << toString(s, s, true);
    end();

    string metadata, deprecateReason;
    bool deprecatedException = s->findMetaData("deprecate", metadata);
    if(deprecatedException)
    {
	deprecateReason = "This module is deprecated.";
	if(metadata.find("deprecate:") == 0 && metadata.size() > 10)
	{
	    deprecateReason = metadata.substr(10);
	}
    }

    start("h2", "Heading");
    _out << "Overview";
    end();

    start("h3", "Synopsis");
    printMetaData(s);
    if(s->isLocal())
    {
	_out << "local ";
    }
    _out << "struct " << s->name();
    end();

    printComment(s, deprecateReason);

    DataMemberList dataMembers = s->dataMembers();

    if(_indexCount > 0 && dataMembers.size() >= _indexCount)
    {
	start("h2");
	_out << "Data Member Index";
	end();
	start("dl");
	for(DataMemberList::const_iterator q = dataMembers.begin(); q != dataMembers.end(); ++q)
	{
	    start("dt", "Symbol");
	    _out << toString(*q, s, false);
	    end();
	    start("dd");
	    string metadata;
	    printSummary(*q, s, (*q)->findMetaData("deprecate", metadata));
	    end();
	}
	end();
    }

    if(!dataMembers.empty())
    {
	start("h2");
	_out << "Data Members";
	end();
	start("dl");
	for(DataMemberList::const_iterator q = dataMembers.begin(); q != dataMembers.end(); ++q)
	{
	    start("dt", "Symbol");
	    printMetaData(*q);
	    TypePtr type = (*q)->type();
	    _out << toString(type, s, false) << " " << toString(*q, s) << ";";
	    end();

	    start("dd");
	    string reason;
	    metadata.clear();
	    if(deprecatedException || (*q)->findMetaData("deprecate", metadata))
	    {
		reason = "This member is deprecated.";
		if(metadata.find("deprecate:") == 0 && metadata.size() > 10)
		{
		    reason = metadata.substr(10);
		}
	    }

	    printComment(*q, reason);
	    end();
	}
	end();
    }
	
    closeDoc();

    assert(_out.currIndent() == indent);
}

Slice::EnumGenerator::EnumGenerator(XMLOutput& o, const Files& files)
    : GeneratorBase(o, files)
{
}

void
Slice::EnumGenerator::generate(const EnumPtr& e)
{
#ifndef NDEBUG
    int indent = _out.currIndent();
#endif

    openDoc(e);

    start("h1", "Symbol");
    _out << toString(e, e->container(), true);
    end();

    string metadata, deprecateReason;
    bool deprecatedException = e->findMetaData("deprecate", metadata);
    if(deprecatedException)
    {
	deprecateReason = "This enumeration is deprecated.";
	if(metadata.find("deprecate:") == 0 && metadata.size() > 10)
	{
	    deprecateReason = metadata.substr(10);
	}
    }

    start("h2");
    _out << "Overview";
    end();

    start("h3", "Synopsis");
    printMetaData(e);
    if(e->isLocal())
    {
	_out << "local ";
    }
    _out << "enum " << e->name();
    end();

    printComment(e, deprecateReason);

    EnumeratorList enumerators = e->getEnumerators();
    if(!enumerators.empty())
    {
	start("h2");
	_out << "Enumerators";
	end();
	start("dl");
	for(EnumeratorList::const_iterator q = enumerators.begin(); q != enumerators.end(); ++q)
	{
	    start("dt", "Symbol");
	    _out << (*q)->name();
	    end();

	    start("dd");
	    string reason;
	    //
	    // Enumerators do not support metadata.
	    //
	    printComment(*q, reason);
	    end();
	}
	end();
    }
	
    closeDoc();

    assert(_out.currIndent() == indent);
}

Slice::Visitor::Visitor(const Files& files)
    : _files(files)
{
}

bool
Slice::Visitor::visitUnitStart(const UnitPtr& unit)
{
    return true;
}

bool
Slice::Visitor::visitModuleStart(const ModulePtr& m)
{
    XMLOutput O;
    ModuleGenerator mg(O, _files);
    mg.generate(m);
    return true;
}

bool
Slice::Visitor::visitExceptionStart(const ExceptionPtr& e)
{
    XMLOutput O;
    ExceptionGenerator eg(O, _files);
    eg.generate(e);
    return true;
}

bool
Slice::Visitor::visitClassDefStart(const ClassDefPtr& c)
{
    XMLOutput O;
    ClassGenerator cg(O, _files);
    cg.generate(c);
    return true;
}

bool
Slice::Visitor::visitStructStart(const StructPtr& s)
{
    XMLOutput O;
    StructGenerator sg(O, _files);
    sg.generate(s);
    return true;
}

void
Slice::Visitor::visitEnum(const EnumPtr& e)
{
    XMLOutput O;
    EnumGenerator eg(O, _files);
    eg.generate(e);
}
