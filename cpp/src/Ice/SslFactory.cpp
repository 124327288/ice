// **********************************************************************
//
// Copyright (c) 2001
// MutableRealms, Inc.
// Huntsville, AL, USA
//
// All Rights Reserved
//
// **********************************************************************

// Note: This pragma is used to disable spurious warning messages having
//       to do with the length of debug symbols exceeding 255 characters.
//       This is due to STL template identifiers expansion.
//       The MSDN Library recommends that you put this pragma directive
//       in place to avoid the warnings.
#ifdef WIN32
#pragma warning(disable:4786)
#endif

#include <Ice/SslFactory.h>
#include <Ice/SslSystemOpenSSL.h>
#include <Ice/Security.h>

#define OPENSSL_THREAD_DEFINES
#include <openssl/opensslconf.h>
#if defined(THREADS)
#else
#error "Thread support not enabled"
#endif


namespace IceSecurity
{

namespace Ssl
{


extern "C"
{
    void lockingCallback(int, int, const char*, int);
}

// Static member instantiations.
IceUtil::Mutex Factory::_systemRepositoryMutex;
SystemMap Factory::_systemRepository;
SslHandleSystemMap Factory::_sslHandleSystemRepository;
int Factory::_evict = 0;

class SslLockKeeper
{

public:
    SslLockKeeper()
    {
        CRYPTO_set_locking_callback((void (*)(int, int, const char*, int))lockingCallback);
    }

    ~SslLockKeeper()
    {
        CRYPTO_set_locking_callback(NULL);
    }

    IceUtil::Mutex sslLocks[CRYPTO_NUM_LOCKS];

};

SslLockKeeper lockKeeper;

}

}

void IceSecurity::Ssl::lockingCallback(int mode, int type, const char *file, int line)
{
    if (mode & CRYPTO_LOCK)
    {
        lockKeeper.sslLocks[type].lock();
    }
    else
    {
        lockKeeper.sslLocks[type].unlock();
    }
}


IceSecurity::Ssl::SystemPtr
IceSecurity::Ssl::Factory::getSystem(string& systemIdentifier)
{
    IceUtil::Mutex::Lock sync(_systemRepositoryMutex);

    SystemPtr system = _systemRepository[systemIdentifier];

    // Don't have that System.
    if (!system)
    {
        // In our case, the systemIdentifier happens to be the
        // SSL Configuration file.

        // This line would change based on the flavor of System that we're
        // creating for the caller.
        system = new OpenSSL::System();

        if (system)
        {
            _systemRepository[systemIdentifier] = system;
        }
    }

    assert(system);

    reapSystems();

    return system;
}

void
IceSecurity::Ssl::Factory::addSystemHandle(void* sslHandle, const SystemPtr& system)
{
    assert(system);
    assert(sslHandle);
    _sslHandleSystemRepository[sslHandle] = system;
}

void
IceSecurity::Ssl::Factory::removeSystemHandle(void* sslHandle)
{
    assert(sslHandle);
    _sslHandleSystemRepository.erase(sslHandle);
}

IceSecurity::Ssl::SystemPtr
IceSecurity::Ssl::Factory::getSystemFromHandle(void* sslHandle)
{
    IceUtil::Mutex::Lock sync(_systemRepositoryMutex);

    assert(sslHandle);

    SystemPtr& system = _sslHandleSystemRepository[sslHandle];

    assert(system);

    reapSystems();

    return system;
}


void
IceSecurity::Ssl::Factory::reapSystems()
{
    if (++_evict >= 10)
    {
        // Note: Double Eviction!  We keep two maps, one keyed on the config file
        //       name that the System is based on (_systemRepository), the other
        //       keyed on a SSL* that was generated by the system in question
        //       (_sslHandleSystemRepository).

        _evict = 0;

	SystemMap::iterator p = _systemRepository.begin();

	while (p != _systemRepository.end())
	{
            // Check the reference count on each System
	    if ((*p).second->__getRef() == 1)
	    {
                // If the Factory System Repository is the only one with a ref to it, erase
		_systemRepository.erase(p++);
	    }
	    else
	    {
		++p;
	    }
	}

/*
	SslHandleSystemMap::iterator r = _sslHandleSystemRepository.begin();

	while (r != _sslHandleSystemRepository.end())
	{
            // Check the reference count on each System
	    if ((*r).second->__getRef() == 1)
	    {
                // If the SSL Handle System Repository is the only one with a ref to it, erase
		_sslHandleSystemRepository.erase(r++);
	    }
	    else
	    {
		++r;
	    }
	}
*/
    }
}

