// **********************************************************************
//
// Copyright (c) 2001
// MutableRealms, Inc.
// Huntsville, AL, USA
//
// All Rights Reserved
//
// **********************************************************************

#include <IceUtil/Functional.h>

#include <Slice/CPlusPlusUtil.h> // TODO: ???
#include <Gen.h>

using namespace std;
using namespace Slice;

static const string internalId = "_internal.";

Slice::Gen::Gen(const string& name, const string& base, const string& include,
		const vector<string>& includePaths, const string& dir,
		const ClassDefPtr& classDef) :
    _base(base),
    _include(include),
    _includePaths(includePaths),
    _classDef(classDef)
{
    _orgName = "http://www.noorg.org"; // TODO: argument!
    for (vector<string>::iterator p = _includePaths.begin(); p != _includePaths.end(); ++p)
    {
	if (p->length() && (*p)[p->length() - 1] != '/')
	{
	    *p += '/';
	}
    }

    string::size_type pos = _base.rfind('/');
    if (pos != string::npos)
    {
	_base.erase(0, pos + 1);
    }

    string fileO = _base + ".wsdl";
    if (!dir.empty())
    {
	fileO = dir + '/' + fileO;
    }

    O.open(fileO.c_str());
    if (!O)
    {
	cerr << name << ": can't open `" << fileO << "' for writing: " << strerror(errno) << endl;
	return;
    }

    printHeader();
    O << "\n<!-- Generated from file `" << changeInclude(_base, _includePaths) << ".ice' -->\n";
}

Slice::Gen::~Gen()
{
}

bool
Slice::Gen::operator!() const
{
    return !O;
}

void
Slice::Gen::generate(const UnitPtr& unit)
{
    unit->mergeModules();

    string scopeId = containedToId(_classDef);

    //
    // TODO: It would be better if start() aligned the attributes
    // correctly.
    //
    ostringstream os;
    os << "wsdl:definitions name=\"" << scopeId << "\""
       << "\n               xmlns:wsdl=\"http://schemas.xmlsoap.org/wsdl/\""
       << "\n               xmlns:xsd1=\"" << _orgName << "/schemas\""
       << "\n               xmlns:tns=\"" << _orgName << "/definitions\""
       << "\n               targetNamespace=\"" << _orgName << "/definitions\"";

    start(os.str());

    // TODO: schemaLocation?
    O << sp << nl << "<wsdl:import namespace=\"" << _orgName << "/schemas\" location=\"" << _base << ".xsd\"/>";


    OperationList ops = _classDef->allOperations();
    for (OperationList::const_iterator q = ops.begin(); q != ops.end(); ++q)
    {
	emitMessage(*q);
    }

    O << sp;

    os.str("");
    os << "wsdl:portType name=\"" << scopeId << "PortType\"";
    start(os.str());

    for (OperationList::const_iterator q = ops.begin(); q != ops.end(); ++q)
    {
	emitOperation(*q);
    }

    end(); // PortType

    end(); // definitions

    O << nl;
}

void
Slice::Gen::emitMessage(const OperationPtr& p)
{
    O << sp;

    string scopeId = containedToId(p);
    
    ostringstream os;
    os << "wsdl:message name=\"input." << p->name() << "\"";
    start(os.str());

    O << nl << "<wsdl:part name=\"body\" element=\"xsd1:" << scopeId << "request." << p->name() << "\"/>";

    end(); // message

    os.str("");
    os << "wsdl:message name=\"output." << p->name() << "\"";
    start(os.str());

    O << nl << "<wsdl:part name=\"body\" element=\"xsd1:" << scopeId << "request." << p->name() << "\"/>";

    end(); // message
}

void
Slice::Gen::emitOperation(const OperationPtr& p)
{
    string scopeId = containedToId(p);
    
    ostringstream os;
    os << "wsdl:operation name=\"" << p->name() << "\"";
    start(os.str());

    O << nl << "<wsdl:input message=\"tns:input." << p->name() << "\">";
    O << nl << "<wsdl:output message=\"tns:output." << p->name() << "\">";

    end(); // operation
}

void
Slice::Gen::printHeader()
{
    static const char* header =
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<!--\n"
"**********************************************************************\n"
"Copyright (c) 2001\n"
"MutableRealms, Inc.\n"
"Huntsville, AL, USA\n"
"\n"
"All Rights Reserved\n"
"\n"
"Generated by the `slice2wsdl' converter\n"
"**********************************************************************\n"
"-->";
    
    O.zeroIndent();
    O << header;
    O << "\n<!-- Ice version " << ICE_STRING_VERSION << " -->";
    O.restoreIndent();
}


void
Slice::Gen::start(const std::string& element)
{
    O << nl << '<' << element << '>';
    O.inc();

    string::size_type pos = element.find_first_of(" \t");
    if (pos == string::npos)
    {
	_elementStack.push(element);
    }
    else
    {
	_elementStack.push(element.substr(0, pos));
    }
}

void
Slice::Gen::end()
{
    string element = _elementStack.top();
    _elementStack.pop();

    O.dec();
    O << nl << "</" << element << '>';
}

string
Slice::Gen::containedToId(const ContainedPtr& contained)
{
    assert(contained);

    string scoped = contained->scope();
    if (scoped[0] == ':')
    {
	scoped.erase(0, 2);
    }

    string id;

    id.reserve(scoped.size());

    for (unsigned int i = 0; i < scoped.size(); ++i)
    {
	if (scoped[i] == ':')
	{
	    id += '.';
	    ++i;
	}
	else
	{
	    id += scoped[i];
	}
    }

    return id;
}

string
Slice::Gen::toString(const SyntaxTreeBasePtr& p)
{
    string tag;
    string linkend;
    string s;

    static const char* builtinTable[] =
    {
	"xs:byte",
	"xs:boolean",
	"xs;short",
	"xs:int",
	"xs:long",
	"xs:float",
	"xs:double",
	"xs:string",
	"ice:_internal.reference", /* Object */
	"ice:_internal.proxyType", /* Object* */
	"???" /* LocalObject */
    };

    BuiltinPtr builtin = BuiltinPtr::dynamicCast(p);
    if (builtin)
    {
	s = builtinTable[builtin->kind()];
	//tag = "type";
    }

    ProxyPtr proxy = ProxyPtr::dynamicCast(p);
    if (proxy)
    {
	s = "ice:_internal.proxyType";
    }

    ClassDeclPtr cl = ClassDeclPtr::dynamicCast(p);
    if (cl)
    {
	string scopeId = containedToId(cl);
	//s = "tns:" + internalId + scopeId + cl->name() + "Type";
	s = "ice:_internal.reference";
    }

    ExceptionPtr ex = ExceptionPtr::dynamicCast(p);
    if (ex)
    {
	string scopeId = containedToId(ex);
	s = "tns:" + internalId + scopeId + ex->name() + "Type";
    }

    StructPtr st = StructPtr::dynamicCast(p);
    if (st)
    {
	string scopeId = containedToId(st);
	s = "tns:" + internalId + scopeId + st->name() + "Type";
    }

    EnumeratorPtr en = EnumeratorPtr::dynamicCast(p);
    if (en)
    {
	string scopeId = containedToId(en);
	s = "tns:" + internalId + scopeId + en->name() + "Type";
    }

    SequencePtr sq = SequencePtr::dynamicCast(p);
    if (sq)
    {
	string scopeId = containedToId(sq);
	s = "tns:" + internalId + scopeId + sq->name() + "Type";
    }

    DictionaryPtr di = DictionaryPtr::dynamicCast(p);
    if (di)
    {
	string scopeId = containedToId(di);
	s = "tns:" + internalId + scopeId + di->name() + "Type";
    }

    EnumPtr em = EnumPtr::dynamicCast(p);
    if (em)
    {
	string scopeId = containedToId(em);
	s = "tns:" + internalId + scopeId + em->name() + "Type";
    }

    return s;
}
