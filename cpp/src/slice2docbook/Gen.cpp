// **********************************************************************
//
// Copyright (c) 2001
// MutableRealms, Inc.
// Huntsville, AL, USA
//
// All Rights Reserved
//
// **********************************************************************

#include <Ice/Functional.h>
#include <Gen.h>
#include <GenUtil.h>

using namespace std;
using namespace Slice;

Slice::Gen::Gen(const string& name)
    : name_(name)
{
}

Slice::Gen::~Gen()
{
}

bool
Slice::Gen::operator!() const
{
    return false;
}

void
Slice::Gen::generate(const Unit_ptr& unit)
{
    unit -> mergeModules();
    unit -> sort();
    unit -> visit(this);
}

void
Slice::Gen::printHeader(Output& out)
{
    static const char* header =
	"<!--\n"
	"Copyright (c) 2001\n"
	"MutableRealms, Inc.\n"
	"Huntsville, AL, USA\n"
	"\n"
	"All Rights Reserved\n"
	"\n"
	"Generated by the `slice2docbook' converter\n"
	"-->";
    
    out.zeroIndent();
    out << nl << header;
    out.restoreIndent();
}

StringList
Slice::Gen::getTagged(const string& tag, string& comment)
{
    StringList result;
    string::size_type begin = 0;
    while(begin < comment.size())
    {
	begin = comment.find("@" + tag, begin);
	if(begin == string::npos)
	    return result;
	
	string::size_type pos1 =
	    comment.find_first_not_of(" \t\r\n", begin + tag.size() + 1);
	if(pos1 == string::npos)
	{
	    comment.erase(begin);
	    return result;
	}
	
	string::size_type pos2 = comment.find('@', pos1);
	string line = comment.substr(pos1, pos2 - pos1);
	comment.erase(begin, pos2 - 1 - begin);

	string::size_type pos3 = line.find_last_not_of(" \t\r\n");
	if(pos3 != string::npos)
	    line.erase(pos3 + 1);
	result.push_back(line);
    }

    return result;
}

void
Slice::Gen::printComment(Output& out, const Contained_ptr& p)
{
    string comment = p -> comment();
    StringList par = getTagged("param", comment);
    StringList ret = getTagged("return", comment);
    StringList throws = getTagged("throws", comment);
    StringList see = getTagged("see", comment);

    start("para");
    string::size_type pos = comment.find_last_not_of(" \t\r\n");
    if(pos != string::npos)
    {
	comment.erase(pos + 1);
	out.zeroIndent();
	out << nl << comment;
	out.restoreIndent();
    }
    end();

    if(!par.empty())
    {
	start("sect2");
	start("title");
	out << nl << "Parameters";
	end();
	start("variablelist");
	for(StringList::iterator p = par.begin();
	    p != par.end();
	    ++p)
	{
	    string::size_type pos;
	    string term;
	    pos = p -> find_first_of(" \t\r\n");
	    if(pos != string::npos)
		term = p -> substr(0, pos);
	    string item;
	    pos = p -> find_first_not_of(" \t\r\n", pos);
	    if(pos != string::npos)
		item = p -> substr(pos);
	    
	    start("varlistentry");
	    start("term");
	    start("parameter");
	    out << nl << term;
	    end();
	    end();
	    start("listitem");
	    start("para");
	    out << nl << item;
	    end();
	    end();
	    end();
	}

	end();
	end();
    }

    if(!ret.empty())
    {
	start("sect2");
	start("title");
	out << nl << "Return Value";
	end();
	start("para");
	out << nl << ret.front();
	end();
	end();
    }

    if(!throws.empty())
    {
	start("sect2");
	start("title");
	out << nl << "Exceptions";
	end();
	start("variablelist");
	
	for(StringList::iterator p = throws.begin();
	    p != throws.end();
	    ++p)
	{
	    string::size_type pos;
	    string term;
	    pos = p -> find_first_of(" \t\r\n");
	    if(pos != string::npos)
		term = p -> substr(0, pos);
	    string item;
	    pos = p -> find_first_not_of(" \t\r\n", pos);
	    if(pos != string::npos)
		item = p -> substr(pos);
	    
	    start("varlistentry");
	    start("term");
	    out << nl << term;
	    end();
	    start("listitem");
	    start("para");
	    out << nl << item;
	    end();
	    end();
	    end();
	}

	end();
	end();
    }

    if(!see.empty())
    {
	start("sect2");
	start("title");
	out << nl << "See Also";
	end();
	start("para");
	start("itemizedlist");
	
	for(StringList::iterator p = see.begin();
	    p != see.end();
	    ++p)
	{
	    start("listitem");
	    start("para");
	    out << nl << *p;
	    end();
	    end();
	}

	end();
	end();
	end();
    }
}

void
Slice::Gen::printSummary(Output& out, const Contained_ptr& p)
{
    string comment = p -> comment();

    start("para");
    string::size_type pos = comment.find('.');
    if(pos != string::npos)
    {
	comment.erase(pos + 1);
	out.zeroIndent();
	out << nl << comment;
	out.restoreIndent();
    }
    end();
}

void
Slice::Gen::pushFile(const string& scoped)
{
    string file = scopedToFile(scoped);
    outputStack_.push(new Output(file.c_str()));
    Output& out = *outputStack_.top();
    if(!out)
    {
	cerr << name_ << ": can't open `" << file << "' for writing: "
	     << strerror(errno) << endl;
    }
}

void
Slice::Gen::popFile()
{
    delete outputStack_.top();
    outputStack_.pop();
}

void
Slice::Gen::start(const std::string& s)
{
    elementStack_.push(s);

    Output& out = *outputStack_.top();
    if(!out)
	return;

    out << nl << '<' << s << '>';
    out.inc();
}

void
Slice::Gen::end()
{
    string s = elementStack_.top();
    elementStack_.pop();

    Output& out = *outputStack_.top();
    if(!out)
	return;

    out.dec();
    out << nl << "</" << s << '>';
}

void
Slice::Gen::visitUnitStart(const Unit_ptr& p)
{
    pushFile("toplevel");

    Output& out = *outputStack_.top();
    if(!out)
	return;

    out << "<!DOCTYPE book PUBLIC \"-//OASIS//DTD DocBook V3.1//EN\">";
    printHeader(out);
    start("book");
}

void
Slice::Gen::visitUnitEnd(const Unit_ptr& p)
{
    Output& out = *outputStack_.top();
    if(!out)
	return;

    end();
    popFile();
}

void
Slice::Gen::visitModuleStart(const Module_ptr& p)
{
/*
    {
	Output& out = *outputStack_.top();
	if(!out)
	    return;

	out << nl << "module " << p -> name() << ';';
    }

    {
	if(!pushFile(p -> scoped()))
	    return; // TODO: Return false

	printComment(out, p);

	out << nl << "module " << p -> name();
	out << sb;
	out.dec();
    }
*/
}

void
Slice::Gen::visitClassDefStart(const ClassDef_ptr& p)
{
    Output& out = *outputStack_.top();
    if(!out)
	return;

    start("chapter");
    start("title");
    out << nl << p -> scoped().substr(2);
    end();

    start("sect1");
    start("title");
    out << nl << "Overview";
    end();

    out.zeroIndent();
    out << "<synopsis>";
    if(p -> isLocal())
	out << "local ";
    if(p -> isInterface())
	out << "interface";
    else
	out << "class";
    out << " <classname>" << p -> name() << "</classname>";
    ClassList bases = p -> bases();
    if(!bases.empty() && !bases.front() -> isInterface())
    {
	out.inc();
	out << nl << "extends ";
	out.inc();
	out << "<classname>" << bases.front() -> scoped().substr(2)
	    << "</classname>";
	bases.pop_front();
	out.dec();
	out.dec();
    }
    if(!bases.empty())
    {
	out.inc();
	if(p -> isInterface())
	    out << nl << "extends ";
	else
	    out << nl << "implements ";
	out.inc();
	ClassList::iterator q = bases.begin();
	while(q != bases.end())
	{
	    out << nl << "<classname>" << (*q) -> scoped().substr(2)
		<< "</classname>";
	    if(++q != bases.end())
		out << ",";
	}
	out.dec();
	out.dec();
    }
    out << "</synopsis>";
    out.restoreIndent();

    printComment(out, p);

    OperationList operations = p -> operations();
    operations.sort();
    if(!operations.empty())
    {
	start("sect2");
	start("title");
	out << nl << "Operation Index";
	end();
	start("variablelist");
	
	for(OperationList::iterator q = operations.begin();
	    q != operations.end();
	    ++q)
	{
	    start("varlistentry");
	    start("term");
	    start("function");
	    out << nl << (*q) -> name();
	    end();
	    end();
	    start("listitem");
	    printSummary(out, *q);
	    end();
	    end();
	}

	end();
	end();
    }

    end();

    for(OperationList::iterator q = operations.begin();
	q != operations.end();
	++q)
    {
	Type_ptr returnType = (*q) -> returnType();
	TypeStringList inputParams = (*q) -> inputParameters();
	TypeStringList outputParams = (*q) -> outputParameters();
	TypeList throws =  (*q) -> throws();
	
	start("sect1");
	start("title");
	out << nl << (*q) -> name();
	end();
	
	out.zeroIndent();
	out << "<synopsis>"
	    << (returnType ? typeToString(returnType) : "<type>void</type>")
	    << " <function>" << (*q) -> name() << "</function>(";
	out.inc();
	TypeStringList::iterator r = inputParams.begin();
	while(r != inputParams.end())
	{
	    out << nl << typeToString(r -> first) << " <parameter>"
		<< r -> second << "</parameter>";
	    if(++r != inputParams.end())
		out << ',';
	}
	if(!outputParams.empty())
	{
	    out << ';';
	    r = outputParams.begin();
	    while(r != outputParams.end())
	    {
		out << nl << typeToString(r -> first) << " <parameter>"
		    << r -> second << "</parameter>";
		if(++r != outputParams.end())
		    out << ',';
	    }
	}
	out << ')';
	out.dec();
	if(!throws.empty())
	{
	    out.inc();
	    out << nl << "throws";
	    out.inc();
	    TypeList::iterator r = throws.begin();
	    while(r != throws.end())
	    {
		out << nl << typeToString(*r);
		if(++r != throws.end())
		    out << ',';
	    }
	    out.dec();
	    out.dec();
	}
	out << ';';
	out << "</synopsis>";
	out.restoreIndent();
	
	printComment(out, *q);
	
	end();
    }

    end();
}

void
Slice::Gen::visitVector(const Vector_ptr& p)
{
/*
    Output& out = *outputStack_.top();
    if(!out)
	return;

    printComment(out, p);

    out << nl << "vector< " << typeToString(p -> type()) << " > "
	<< p -> name() << ';';
*/
}

void
Slice::Gen::visitNative(const Native_ptr& p)
{
/*
    Output& out = *outputStack_.top();
    if(!out)
	return;

    printComment(out, p);

    out << nl << "native " << p -> name() << ';';
*/
}
