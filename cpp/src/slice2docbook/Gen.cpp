// **********************************************************************
//
// Copyright (c) 2001
// MutableRealms, Inc.
// Huntsville, AL, USA
//
// All Rights Reserved
//
// **********************************************************************

#include <Ice/Functional.h>
#include <Gen.h>
#include <GenUtil.h>

using namespace std;
using namespace Slice;

Slice::Gen::Gen(const string& name)
    : name_(name)
{
}

Slice::Gen::~Gen()
{
}

bool
Slice::Gen::operator!() const
{
    return false;
}

void
Slice::Gen::generate(const Unit_ptr& unit)
{
    unit -> mergeModules();
    unit -> sort();
    unit -> visit(this);
}

void
Slice::Gen::printHeader(Output& out)
{
    static const char* header =
	"Copyright (c) 2001\n"
	"MutableRealms, Inc.\n"
	"Huntsville, AL, USA\n"
	"\n"
	"All Rights Reserved\n"
	"\n"
	"Generated by the `slice2docbook' converter\n";

    out << header;
}

void
Slice::Gen::visitUnitStart(const Unit_ptr& p)
{
    string file = scopedToFile("toplevel");
    outputStack_.push(new Output(file.c_str()));
    Output& out = *outputStack_.top();
    if(!out)
    {
	cerr << name_ << ": can't open `" << file << "' for writing: "
	     << strerror(errno) << endl;
	return;
    }
    printHeader(out);
}

void
Slice::Gen::visitUnitEnd(const Unit_ptr& p)
{
    Output& out = *outputStack_.top();
    if(!out)
	return;

    out << '\n';

    delete outputStack_.top();
    outputStack_.pop();
}

void
Slice::Gen::visitModuleStart(const Module_ptr& p)
{
    {
	Output& out = *outputStack_.top();
	if(!out)
	    return;

	out << sp;
	out << nl << "module " << p -> name() << ';';
    }

    {
	string file = scopedToFile(p -> scoped());
	outputStack_.push(new Output(file.c_str()));
	Output& out = *outputStack_.top();
	if(!out)
	{
	    cerr << name_ << ": can't open `" << file << "' for writing: "
		 << strerror(errno) << endl;
	    return;
	}
	printHeader(out);

	string comment = p -> comment();
	if(comment.length())
	{
	    out << sp;
	    out << nl << comment;
	}

	out << sp;
	out << nl << "module " << p -> name();
	out << sb;
	out.dec();
    }
}

void
Slice::Gen::visitModuleEnd(const Module_ptr& p)
{
    Output& out = *outputStack_.top();
    if(!out)
	return;

    out << sp;
    out.inc();
    out << eb << ';';

    delete outputStack_.top();
    outputStack_.pop();
}

void
Slice::Gen::visitClassDefStart(const ClassDef_ptr& p)
{
    {
	Output& out = *outputStack_.top();
	if(!out)
	    return;
	
	out << sp;
	out << nl;
	if(p -> isLocal())
	    out << "isLocal ";
	out << "class " << p -> name() << ';';
    }

    {
	string file = scopedToFile(p -> scoped());
	outputStack_.push(new Output(file.c_str()));
	Output& out = *outputStack_.top();
	if(!out)
	{
	    cerr << name_ << ": can't open `" << file << "' for writing: "
		 << strerror(errno) << endl;
	    return;
	}
	printHeader(out);
	
	string comment = p -> comment();
	if(comment.length())
	{
	    out << sp;
	    out << nl << comment;
	}

	out << sp;
	out << nl;
	if(p -> isLocal())
	    out << "local ";
	if(p -> isInterface())
	    out << "interface ";
	else
	    out << "class ";
	out << p -> name();
	ClassList bases = p -> bases();
	if(!bases.empty() && !bases.front() -> isInterface())
	{
	    out << " extends " << bases.front() -> scoped().substr(2);
	    bases.pop_front();
	}
	if(!bases.empty())
	{
	    if(p -> isInterface())
		out << " extends ";
	    else
		out << " implements ";
	}
	ClassList::iterator q = bases.begin();
	while(q != bases.end())
	{
	    out << (*q) -> scoped().substr(2);
	    if(++q != bases.end())
		out << ", ";
	}	
	out << sb;
    }
}

void
Slice::Gen::visitClassDefEnd(const ClassDef_ptr& p)
{
    Output& out = *outputStack_.top();
    if(!out)
	return;

    out << eb << ';';

    delete outputStack_.top();
    outputStack_.pop();
}

void
Slice::Gen::visitOperation(const Operation_ptr& p)
{
    Output& out = *outputStack_.top();
    if(!out)
	return;

    Type_ptr returnType = p -> returnType();
    TypeStringList inputParams = p -> inputParameters();
    TypeStringList outputParams = p -> outputParameters();
    TypeList throws =  p -> throws();
    
    string comment = p -> comment();
    if(comment.length())
    {
	out << sp;
	out << nl << comment;
    }

    out << sp;
    out << nl << (returnType ? typeToString(returnType) : "void") << ' '
	<< p -> name() << '(';
    out.useCurrentPosAsIndent();
    TypeStringList::iterator q = inputParams.begin();
    while(q != inputParams.end())
    {
	out << typeToString(q -> first) << ' ' << q -> second;
	if(++q != inputParams.end())
	    out << ',' << nl;
    }
    if(!outputParams.empty())
    {
	out << ';' << nl;
	q = outputParams.begin();
	while(q != outputParams.end())
	{
	    out << typeToString(q -> first) << ' ' << q -> second;
	    if(++q != outputParams.end())
		out << ',' << nl;
	}
    }
    out << ')';
    out.restoreIndent();
    if(!throws.empty())
    {
	out.inc();
	out << nl << "throws ";
	out.useCurrentPosAsIndent();
	TypeList::iterator r = throws.begin();
	while(r != throws.end())
	{
	    out << typeToString(*r);
	    if(++r != throws.end())
		out << ',' << nl;
	}
	out.restoreIndent();
	out.dec();
    }
    out << ';';
}

void
Slice::Gen::visitDataMember(const DataMember_ptr& p)
{
    Output& out = *outputStack_.top();
    if(!out)
	return;

    string comment = p -> comment();
    if(comment.length())
    {
	out << sp;
	out << nl << comment;
    }

    out << sp;
    out << nl << typeToString(p -> type()) << ' ' << p -> name() << ';';
}

void
Slice::Gen::visitVector(const Vector_ptr& p)
{
    Output& out = *outputStack_.top();
    if(!out)
	return;

    string comment = p -> comment();
    if(comment.length())
    {
	out << sp;
	out << nl << comment;
    }

    out << sp;
    out << nl << "vector< " << typeToString(p -> type()) << " > "
	<< p -> name() << ';';
}

void
Slice::Gen::visitNative(const Native_ptr& p)
{
    Output& out = *outputStack_.top();
    if(!out)
	return;

    string comment = p -> comment();
    if(comment.length())
    {
	out << sp;
	out << nl << comment;
    }

    out << sp;
    out << nl << "native " << p -> name() << ';';
}

