Introduction
============

Ice-E is a compact subset of Ice designed for embedded environments
while retaining many of the features that have made Ice such a
compelling alternative for distributed applications.


Comparing Ice-E and Ice
=======================

In order to reduce the size of the Ice-E run time, several Ice
features have been removed, and others are optional. The differences
are discussed in the sections below.

Concurrency Models
------------------

Ice-E supports only the thread-per-connection concurrency model; the
thread pool concurrency model is not supported. Applications that
make nested callbacks must be aware of the following limitations of
the thread-per-connection model:

* For bidirectional connections, the nested callback must be a oneway
  invocation.

* For regular (unidirectional) connections, the nested callback can
  be a twoway invocation.

* Only one level of nested callbacks is allowed.

Transports
----------

Ice-E includes support for the TCP transport; UDP and SSL are not
supported. The built-in TCP transport can be replaced with one of your
own.

Objects by Value
----------------

Ice-E does not allow Slice classes to be transmitted by value,
although it is still possible to use Slice classes in a local context.

Servant Locators
----------------

Ice-E does not support servant locators. Ice-E applications must
use the active servant map.

Collocation Optimization
------------------------

Support for collocation optimization has been removed. Note that
Ice-E applications are still able to make invocations on collocated
servants, but those invocations are not optimized and therefore will
be marshaled and sent over the built-in transport.

Other Removed Features
----------------------

Ice-E has also eliminated the following features:

* Asynchronous invocation and dispatch
* Streaming APIs
* Active connection management
* Protocol compression
* Ice::Application and Ice::Service classes

Optional Features
-----------------

Support for routers, locators and batch messages is enabled by
default but can be removed in order to further reduce the size of
the Ice-E run time. See the "Configuration" section below for more
information.

Compatibility
-------------

Ice-E and Ice share the same C++ mapping and remain source-code
compatible, given the limitations described above. Furthermore,
since the two products also share the same protocol, a distributed
system can use any combination of Ice and Ice-E applications.

Customization
-------------

If the current features do not meet your requirements, ZeroC can
customize Ice-E for commercial users. Please contact us at
info@zeroc.com for more information.


Run-time Libraries
==================

In order to minimize the size of Ice-E applications, two versions of
the run time library are provided:

* The "client" library is suitable for applications requiring only
  client-side functionality.

* The "server" library supports client- and server-side functionality.

A simple rule of thumb is to use the server library if your program
creates an object adapter, otherwise you can use the client library.

Users of the client library must define the preprocessor macro
ICEE_PURE_CLIENT when compiling an application as well as link with
the appropriate run time library.


Configuration
=============

You may build the Ice-E run time libraries with certain components
disabled in order to further reduce the size of your applications. The
default configuration enables all of the optional components, but you
can selectively disable them by editing the file include/IceE/Config.h
and commenting out their corresponding preprocessor macros. The
optional components are described below. For more information on these
features, please refer to the Ice manual.

Router Support
--------------

If ICEE_HAS_ROUTER is defined, the Ice-E libraries will include
support for routers. This component is necessary in order to use
Ice-E with the Glacier2 router.

Applications that use routers often also receive callbacks from remote
servers. These applications must use the server library, because the
client library does not provide support for callbacks.

Locator Support
---------------

If ICEE_HAS_LOCATOR is defined, the Ice-E libraries will include
support for locators. This component is necessary in order to use
indirect proxies in Ice-E.

Batch Messages Support
----------------------

If ICEE_HAS_BATCH is defined, the Ice-E client library will include
support for sending batch messages. This feature cannot be disabled
in the server library.


Blocking Client Support
-----------------------

If ICEE_PURE_BLOCKING_CLIENT is defined, the Ice-E client library will
include support only for the blocking client-side concurrency model. If
it is not defined or the server library is being used the blocking model
can still be chosen by setting the --Ice.Blocking property.


Alternate Sequence Mapping
==========================

By default, slice sequences map to std::vector in C++. However it is 
possible to control the type that is generated for sequences though the
use of metadata. Any user defined class may be used as the sequence type
as long as it conforms to the following constraints:

 * has default constructor
 * has copy constructor
 * has constructor which take initial size of sequence as paramater
 * implements size() to return current sequence size
 * implements swap() to swap contents with another class of same type
 * has a iterator and const_iterator and implements begin() and end()
 * is responsible for it's own memory management

std::vector, std::list and std::deque all conform to the above and thus
can all be used.

To set an alternate mapping for a sequence in slice you use the following
sytax:

["cpp:type:std::deque< ::Ice::Byte>"] sequence<byte> ByteSeq;

This will cause a std::deque to be used wherever you use ByteSeq in your
slice definitions. You can also sepcify an alternate mapping for only a
specific use of a sequence type, such as a specific operation paramater.
The syntax for modifying mapping of operation paramaters or class and
structure members is as follows:

struct S
{
    ["cpp:type:std::list< ::Ice::Byte>"] ByteSeq b;
};

class C
{
    ["cpp:type:list< ::Ice::Byte>"] op(["cpp:type:list< ::Ice::Byte>"] ByteSeq bs);

    ["cpp:type:list< ::Ice::Byte>""] ByteSeq b;    
};

There are also two special mapping that can only be used for operation in
paramaters, array and range. The array mapping maps the slice sequence to 
a pair of pointers [first, last) to the sequences contained type. For example

class C
{
    void op(["cpp:array"] ByteSeq bs);
};

will map to std::pair<const Ice::Byte*, const Ice::Byte*>.

For byte sequences these pointers will point directly into the marshall
stream, meaning that no extra copy is done on the server side, thus
improving performance.

The range mapping maps to a pair of const_iterators that point to the
begining and end of the sequence. For example

class C
{
    void op(["cpp:range"] ByteSeq bs);
    };
};

will map to std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator>

It is also possible to specify a different sequence type with the range
metadata. For example

class C
{
    void op(["cpp:range:std::deque< ::Ice::Byte>"] ByteSeq bs);
};

will map to std::pair<std::deque< ::Ice::Byte>::const_iterator, std::deque< ::Ice::Byte>::const_iterator>

Finally, when using a alternate sequence mapping it is usually necessary
for the generated header file to include the file defining the alternate
type in order for the generated code to compile. Extra includes can also 
be specified with metadata. For example if you make use of std::list and
std::deque in your slice you would add the following at the top of your
slice file.

[["cpp:include:deque", "cpp:include:list"]]

Please take a look at test/IceE/custom for code examples of the use of
alternate C++ sequence mappings.


Installation
============

For installation instructions, please refer to the INSTALL.* file for
your plaftorm.
